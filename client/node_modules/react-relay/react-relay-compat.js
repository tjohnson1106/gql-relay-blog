/**
 * Relay v1.7.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("fbjs/lib/invariant"), require("relay-runtime"), require("react"), require("babel-runtime/helpers/extends"), require("fbjs/lib/warning"), require("babel-runtime/helpers/classCallCheck"), require("fbjs/lib/areEqual"), require("fbjs/lib/sprintf"), require("babel-runtime/helpers/inherits"), require("babel-runtime/helpers/possibleConstructorReturn"), require("prop-types"), require("babel-runtime/helpers/objectWithoutProperties"), require("fbjs/lib/mapObject"), require("babel-runtime/helpers/defineProperty"), require("fbjs/lib/base62"), require("fbjs/lib/forEachObject"), require("fbjs/lib/nullthrows"));
	else if(typeof define === 'function' && define.amd)
		define(["fbjs/lib/invariant", "relay-runtime", "react", "babel-runtime/helpers/extends", "fbjs/lib/warning", "babel-runtime/helpers/classCallCheck", "fbjs/lib/areEqual", "fbjs/lib/sprintf", "babel-runtime/helpers/inherits", "babel-runtime/helpers/possibleConstructorReturn", "prop-types", "babel-runtime/helpers/objectWithoutProperties", "fbjs/lib/mapObject", "babel-runtime/helpers/defineProperty", "fbjs/lib/base62", "fbjs/lib/forEachObject", "fbjs/lib/nullthrows"], factory);
	else if(typeof exports === 'object')
		exports["ReactRelayCompat"] = factory(require("fbjs/lib/invariant"), require("relay-runtime"), require("react"), require("babel-runtime/helpers/extends"), require("fbjs/lib/warning"), require("babel-runtime/helpers/classCallCheck"), require("fbjs/lib/areEqual"), require("fbjs/lib/sprintf"), require("babel-runtime/helpers/inherits"), require("babel-runtime/helpers/possibleConstructorReturn"), require("prop-types"), require("babel-runtime/helpers/objectWithoutProperties"), require("fbjs/lib/mapObject"), require("babel-runtime/helpers/defineProperty"), require("fbjs/lib/base62"), require("fbjs/lib/forEachObject"), require("fbjs/lib/nullthrows"));
	else
		root["ReactRelayCompat"] = factory(root["fbjs/lib/invariant"], root["relay-runtime"], root["react"], root["babel-runtime/helpers/extends"], root["fbjs/lib/warning"], root["babel-runtime/helpers/classCallCheck"], root["fbjs/lib/areEqual"], root["fbjs/lib/sprintf"], root["babel-runtime/helpers/inherits"], root["babel-runtime/helpers/possibleConstructorReturn"], root["prop-types"], root["babel-runtime/helpers/objectWithoutProperties"], root["fbjs/lib/mapObject"], root["babel-runtime/helpers/defineProperty"], root["fbjs/lib/base62"], root["fbjs/lib/forEachObject"], root["fbjs/lib/nullthrows"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_16__, __WEBPACK_EXTERNAL_MODULE_17__, __WEBPACK_EXTERNAL_MODULE_18__, __WEBPACK_EXTERNAL_MODULE_22__, __WEBPACK_EXTERNAL_MODULE_31__, __WEBPACK_EXTERNAL_MODULE_44__, __WEBPACK_EXTERNAL_MODULE_45__, __WEBPACK_EXTERNAL_MODULE_46__, __WEBPACK_EXTERNAL_MODULE_47__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	/**
	 * The public interface to React Relay which supports a compatibility mode to
	 * continue to work with the classic Relay runtime.
	 */
	module.exports = {
	  QueryRenderer: __webpack_require__(34),

	  MutationTypes: __webpack_require__(2).MutationTypes,
	  RangeOperations: __webpack_require__(2).RangeOperations,

	  applyOptimisticMutation: __webpack_require__(23).applyUpdate,
	  commitMutation: __webpack_require__(23).commitUpdate,
	  createFragmentContainer: __webpack_require__(36).createContainer,
	  createPaginationContainer: __webpack_require__(37).createContainer,
	  createRefetchContainer: __webpack_require__(38).createContainer,
	  fetchQuery: __webpack_require__(2).fetchQuery,
	  graphql: __webpack_require__(2).graphql,

	  injectDefaultVariablesProvider: __webpack_require__(14).injectDefaultVariablesProvider
	};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var EMPTY_CALLS = [];
	var EMPTY_CHILDREN = [];
	var EMPTY_DIRECTIVES = [];
	var EMPTY_METADATA = {};

	if (true) {
	  Object.freeze(EMPTY_CALLS);
	  Object.freeze(EMPTY_CHILDREN);
	  Object.freeze(EMPTY_DIRECTIVES);
	  Object.freeze(EMPTY_METADATA);
	}

	/**
	 * @internal
	 *
	 * Helper methods for constructing concrete query objects.
	 */
	var QueryBuilder = {
	  createBatchCallVariable: function createBatchCallVariable(sourceQueryID, jsonPath) {
	    return {
	      kind: 'BatchCallVariable',
	      sourceQueryID: sourceQueryID,
	      jsonPath: jsonPath
	    };
	  },
	  createCall: function createCall(name, value, type) {
	    return {
	      kind: 'Call',
	      name: name,
	      metadata: {
	        type: type || null
	      },
	      value: value
	    };
	  },
	  createCallValue: function createCallValue(callValue) {
	    return {
	      kind: 'CallValue',
	      callValue: callValue
	    };
	  },
	  createCallVariable: function createCallVariable(callVariableName) {
	    return {
	      kind: 'CallVariable',
	      callVariableName: callVariableName
	    };
	  },
	  createDirective: function createDirective(name, args) {
	    return {
	      args: args,
	      kind: 'Directive',
	      name: name
	    };
	  },
	  createDirectiveArgument: function createDirectiveArgument(name, value) {
	    return {
	      name: name,
	      value: value
	    };
	  },
	  createField: function createField(partialField) {
	    var partialMetadata = partialField.metadata || EMPTY_METADATA;
	    return {
	      alias: partialField.alias,
	      calls: partialField.calls || EMPTY_CALLS,
	      children: partialField.children || EMPTY_CHILDREN,
	      directives: partialField.directives || EMPTY_DIRECTIVES,
	      fieldName: partialField.fieldName,
	      kind: 'Field',
	      metadata: {
	        canHaveSubselections: !!partialMetadata.canHaveSubselections,
	        inferredRootCallName: partialMetadata.inferredRootCallName,
	        inferredPrimaryKey: partialMetadata.inferredPrimaryKey,
	        isConnection: !!partialMetadata.isConnection,
	        isFindable: !!partialMetadata.isFindable,
	        isGenerated: !!partialMetadata.isGenerated,
	        isPlural: !!partialMetadata.isPlural,
	        isRequisite: !!partialMetadata.isRequisite,
	        isAbstract: !!partialMetadata.isAbstract
	      },
	      type: partialField.type
	    };
	  },
	  createFragment: function createFragment(partialFragment) {
	    var metadata = partialFragment.metadata || EMPTY_METADATA;
	    return {
	      children: partialFragment.children || EMPTY_CHILDREN,
	      directives: partialFragment.directives || EMPTY_DIRECTIVES,
	      id: __webpack_require__(29)(),
	      kind: 'Fragment',
	      metadata: {
	        isAbstract: !!metadata.isAbstract,
	        pattern: !!metadata.pattern,
	        plural: !!metadata.plural // match the `@relay` argument name
	      },
	      name: partialFragment.name,
	      type: partialFragment.type
	    };
	  },
	  createMutation: function createMutation(partialMutation) {
	    var metadata = partialMutation.metadata || EMPTY_METADATA;
	    return {
	      calls: partialMutation.calls || EMPTY_CALLS,
	      children: partialMutation.children || EMPTY_CHILDREN,
	      directives: partialMutation.directives || EMPTY_DIRECTIVES,
	      kind: 'Mutation',
	      metadata: {
	        inputType: metadata.inputType
	      },
	      name: partialMutation.name,
	      responseType: partialMutation.responseType
	    };
	  },
	  createQuery: function createQuery(partialQuery) {
	    var metadata = partialQuery.metadata || EMPTY_METADATA;
	    var calls = [];
	    var identifyingArgName = metadata.identifyingArgName;
	    if (identifyingArgName == null && __webpack_require__(26).isNodeRootCall(partialQuery.fieldName)) {
	      identifyingArgName = __webpack_require__(26).ID;
	    }
	    if (identifyingArgName != null) {
	       true ? __webpack_require__(8)(partialQuery.identifyingArgValue != null, 'QueryBuilder.createQuery(): An argument value may be required for ' + 'query `%s(%s: ???)`.', partialQuery.fieldName, identifyingArgName) : void 0;
	      calls = [QueryBuilder.createCall(identifyingArgName, partialQuery.identifyingArgValue, metadata.identifyingArgType)];
	    }
	    return {
	      calls: calls,
	      children: partialQuery.children || EMPTY_CHILDREN,
	      directives: partialQuery.directives || EMPTY_DIRECTIVES,
	      fieldName: partialQuery.fieldName,
	      isDeferred: !!(partialQuery.isDeferred || metadata.isDeferred),
	      kind: 'Query',
	      metadata: {
	        identifyingArgName: identifyingArgName,
	        identifyingArgType: metadata.identifyingArgType,
	        isAbstract: !!metadata.isAbstract,
	        isPlural: !!metadata.isPlural
	      },
	      name: partialQuery.name,
	      type: partialQuery.type
	    };
	  },
	  createSubscription: function createSubscription(partialSubscription) {
	    var metadata = partialSubscription.metadata || EMPTY_METADATA;
	    return {
	      calls: partialSubscription.calls || EMPTY_CALLS,
	      children: partialSubscription.children || EMPTY_CHILDREN,
	      directives: partialSubscription.directives || EMPTY_DIRECTIVES,
	      kind: 'Subscription',
	      metadata: {
	        inputType: metadata.inputType
	      },
	      name: partialSubscription.name,
	      responseType: partialSubscription.responseType
	    };
	  },
	  getBatchCallVariable: function getBatchCallVariable(node) {
	    if (isConcreteKind(node, 'BatchCallVariable')) {
	      return node;
	    }
	  },
	  getCallVariable: function getCallVariable(node) {
	    if (isConcreteKind(node, 'CallVariable')) {
	      return node;
	    }
	  },
	  getField: function getField(node) {
	    if (isConcreteKind(node, 'Field')) {
	      return node;
	    }
	  },
	  getFragment: function getFragment(node) {
	    if (isConcreteKind(node, 'Fragment')) {
	      return node;
	    }
	  },
	  getFragmentDefinition: function getFragmentDefinition(node) {
	    if (isConcreteKind(node, 'FragmentDefinition')) {
	      return node;
	    }
	  },
	  getFragmentSpread: function getFragmentSpread(node) {
	    if (isConcreteKind(node, 'FragmentSpread')) {
	      return node;
	    }
	  },
	  getOperationDefinition: function getOperationDefinition(node) {
	    if (isConcreteKind(node, 'OperationDefinition')) {
	      return node;
	    }
	  },
	  getMutation: function getMutation(node) {
	    if (isConcreteKind(node, 'Mutation')) {
	      return node;
	    }
	  },
	  getQuery: function getQuery(node) {
	    if (isConcreteKind(node, 'Query')) {
	      return node;
	    }
	  },
	  getSubscription: function getSubscription(node) {
	    if (isConcreteKind(node, 'Subscription')) {
	      return node;
	    }
	  }
	};

	function isConcreteKind(node, kind) {
	  return typeof node === 'object' && node !== null && node.kind === kind;
	}

	module.exports = QueryBuilder;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Asserts that the input is a matches the `RelayContext` type defined in
	 * `RelayEnvironmentTypes` and returns it as that type.
	 */
	function assertRelayContext(relay) {
	  !isRelayContext(relay) ?  true ? __webpack_require__(1)(false, 'RelayContext: Expected `context.relay` to be an object conforming to ' + 'the `RelayContext` interface, got `%s`.', relay) : require('fbjs/lib/invariant')(false) : void 0;
	  return relay;
	}

	/**
	 * Determine if the input is a plain object that matches the `RelayContext`
	 * type defined in `RelayEnvironmentTypes`.
	 */
	function isRelayContext(context) {
	  return typeof context === 'object' && context !== null && !Array.isArray(context) && __webpack_require__(30)(context.environment) && __webpack_require__(42)(context.variables);
	}

	module.exports = {
	  assertRelayContext: assertRelayContext,
	  isRelayContext: isRelayContext
	};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	function getComponentName(component) {
	  return component.displayName || component.name || 'Component';
	}

	function getContainerName(Component) {
	  return 'Relay(' + getComponentName(Component) + ')';
	}

	module.exports = {
	  getComponentName: getComponentName,
	  getContainerName: getContainerName
	};

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/** The external API of 'fetch' **/


	// Internally we keep an array of onDataChange callbacks, to support reusing
	// the queryRenderer for multiple components.
	var ReactRelayQueryFetcher = function () {
	  function ReactRelayQueryFetcher(args) {
	    (0, _classCallCheck3['default'])(this, ReactRelayQueryFetcher);
	    this._selectionReferences = [];
	    this._callOnDataChangeWhenSet = false;

	    if (args != null) {
	      this._cacheSelectionReference = args.cacheSelectionReference;
	      this._selectionReferences = args.selectionReferences;
	    }
	  } // results of the root fragment;
	  // fetch error


	  ReactRelayQueryFetcher.prototype.getSelectionReferences = function getSelectionReferences() {
	    return {
	      cacheSelectionReference: this._cacheSelectionReference,
	      selectionReferences: this._selectionReferences
	    };
	  };

	  ReactRelayQueryFetcher.prototype.lookupInStore = function lookupInStore(environment, operation) {
	    if (environment.check(operation.root)) {
	      this._retainCachedOperation(environment, operation);
	      return environment.lookup(operation.fragment);
	    }
	    return null;
	  };

	  ReactRelayQueryFetcher.prototype.execute = function execute(_ref) {
	    var _this = this;

	    var environment = _ref.environment,
	        operation = _ref.operation,
	        cacheConfig = _ref.cacheConfig,
	        _ref$preservePrevious = _ref.preservePreviousReferences,
	        preservePreviousReferences = _ref$preservePrevious === undefined ? false : _ref$preservePrevious;
	    var createOperationSelector = environment.unstable_internal.createOperationSelector;

	    var nextReferences = [];

	    return environment.execute({ operation: operation, cacheConfig: cacheConfig }).map(function (payload) {
	      var operationForPayload = createOperationSelector(operation.node, payload.variables, payload.operation);
	      nextReferences.push(environment.retain(operationForPayload.root));
	      return payload;
	    })['do']({
	      error: function error() {
	        // We may have partially fulfilled the request, so let the next request
	        // or the unmount dispose of the references.
	        _this._selectionReferences = _this._selectionReferences.concat(nextReferences);
	      },
	      complete: function complete() {
	        if (!preservePreviousReferences) {
	          _this.disposeSelectionReferences();
	        }
	        _this._selectionReferences = _this._selectionReferences.concat(nextReferences);
	      },
	      unsubscribe: function unsubscribe() {
	        // Let the next request or the unmount code dispose of the references.
	        // We may have partially fulfilled the request.
	        _this._selectionReferences = _this._selectionReferences.concat(nextReferences);
	      }
	    });
	  };

	  ReactRelayQueryFetcher.prototype.setOnDataChange = function setOnDataChange(onDataChange) {
	    !this._fetchOptions ?  true ? __webpack_require__(1)(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : require('fbjs/lib/invariant')(false) : void 0;

	    if (typeof onDataChange === 'function') {
	      // Mutate the most recent fetchOptions in place,
	      // So that in-progress requests can access the updated callback.
	      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];
	      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);

	      if (this._callOnDataChangeWhenSet) {
	        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set
	        if (this._error != null) {
	          onDataChange({ error: this._error });
	        } else if (this._snapshot != null) {
	          onDataChange({ snapshot: this._snapshot });
	        }
	      }
	    }
	  };

	  /**
	   * `fetch` fetches the data for the given operation.
	   * If a result is immediately available synchronously, it will be synchronously
	   * returned by this function.
	   *
	   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.
	   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),
	   * and then subsequently whenever the data changes.
	   */


	  ReactRelayQueryFetcher.prototype.fetch = function fetch(fetchOptions) {
	    var _this2 = this;

	    var cacheConfig = fetchOptions.cacheConfig,
	        environment = fetchOptions.environment,
	        operation = fetchOptions.operation,
	        onDataChange = fetchOptions.onDataChange;

	    var fetchHasReturned = false;
	    var error = void 0;

	    this.disposeRequest();
	    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;
	    this._fetchOptions = {
	      cacheConfig: cacheConfig,
	      environment: environment,
	      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],
	      operation: operation
	    };

	    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {
	      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);
	    }

	    var request = this.execute({
	      environment: environment,
	      operation: operation,
	      cacheConfig: cacheConfig
	    })['finally'](function () {
	      _this2._pendingRequest = null;
	    }).subscribe({
	      next: function next() {
	        // If we received a response,
	        // Make a note that to notify the callback when it's later added.
	        _this2._callOnDataChangeWhenSet = true;
	        _this2._error = null;

	        // Only notify of the first result if `next` is being called **asynchronously**
	        // (i.e. after `fetch` has returned).
	        _this2._onQueryDataAvailable({ notifyFirstResult: fetchHasReturned });
	      },
	      error: function (_error) {
	        function error(_x) {
	          return _error.apply(this, arguments);
	        }

	        error.toString = function () {
	          return _error.toString();
	        };

	        return error;
	      }(function (err) {
	        // If we received a response when we didn't have a change callback,
	        // Make a note that to notify the callback when it's later added.
	        _this2._callOnDataChangeWhenSet = true;
	        _this2._error = err;
	        _this2._snapshot = null;

	        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks;

	        // Only notify of error if `error` is being called **asynchronously**
	        // (i.e. after `fetch` has returned).
	        if (fetchHasReturned) {
	          if (onDataChangeCallbacks) {
	            onDataChangeCallbacks.forEach(function (onDataChange) {
	              onDataChange({ error: err });
	            });
	          }
	        } else {
	          error = err;
	        }
	      })
	    });

	    this._pendingRequest = {
	      dispose: function dispose() {
	        request.unsubscribe();
	      }
	    };

	    fetchHasReturned = true;

	    if (error) {
	      throw error;
	    }

	    return this._snapshot;
	  };

	  ReactRelayQueryFetcher.prototype.retry = function retry() {
	    !this._fetchOptions ?  true ? __webpack_require__(1)(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : require('fbjs/lib/invariant')(false) : void 0;
	    return this.fetch({
	      cacheConfig: this._fetchOptions.cacheConfig,
	      environment: this._fetchOptions.environment,
	      operation: this._fetchOptions.operation,
	      onDataChange: null // If there are onDataChangeCallbacks they will be reused
	    });
	  };

	  ReactRelayQueryFetcher.prototype.dispose = function dispose() {
	    this.disposeRequest();
	    this.disposeSelectionReferences();
	  };

	  ReactRelayQueryFetcher.prototype.disposeRequest = function disposeRequest() {
	    this._error = null;
	    this._snapshot = null;

	    // order is important, dispose of pendingFetch before selectionReferences
	    if (this._pendingRequest) {
	      this._pendingRequest.dispose();
	    }
	    if (this._rootSubscription) {
	      this._rootSubscription.dispose();
	      this._rootSubscription = null;
	    }
	  };

	  ReactRelayQueryFetcher.prototype._retainCachedOperation = function _retainCachedOperation(environment, operation) {
	    this._disposeCacheSelectionReference();
	    this._cacheSelectionReference = environment.retain(operation.root);
	  };

	  ReactRelayQueryFetcher.prototype._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {
	    this._cacheSelectionReference && this._cacheSelectionReference.dispose();
	    this._cacheSelectionReference = null;
	  };

	  ReactRelayQueryFetcher.prototype.disposeSelectionReferences = function disposeSelectionReferences() {
	    this._disposeCacheSelectionReference();
	    this._selectionReferences.forEach(function (r) {
	      return r.dispose();
	    });
	    this._selectionReferences = [];
	  };

	  ReactRelayQueryFetcher.prototype._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {
	    var _this3 = this;

	    var notifyFirstResult = _ref2.notifyFirstResult;

	    !this._fetchOptions ?  true ? __webpack_require__(1)(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : require('fbjs/lib/invariant')(false) : void 0;
	    var _fetchOptions = this._fetchOptions,
	        environment = _fetchOptions.environment,
	        onDataChangeCallbacks = _fetchOptions.onDataChangeCallbacks,
	        operation = _fetchOptions.operation;

	    // `_onQueryDataAvailable` can be called synchronously the first time and can be called
	    // multiple times by network layers that support data subscriptions.
	    // Wait until the first payload to call `onDataChange` and subscribe for data updates.

	    if (this._snapshot) {
	      return;
	    }

	    this._snapshot = environment.lookup(operation.fragment);

	    // Subscribe to changes in the data of the root fragment
	    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {
	      // Read from this._fetchOptions in case onDataChange() was lazily added.
	      if (_this3._fetchOptions != null) {
	        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;
	        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {
	          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {
	            return onDataChange({ snapshot: snapshot });
	          });
	        }
	      }
	    });

	    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {
	      var _snapshot = this._snapshot;
	      onDataChangeCallbacks.forEach(function (onDataChange) {
	        return onDataChange({ snapshot: _snapshot });
	      });
	    }
	  };

	  return ReactRelayQueryFetcher;
	}();

	module.exports = ReactRelayQueryFetcher;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var RelayPropTypes = {
	  Container: function Container(props, propName, componentName) {
	    var component = props[propName];
	    if (component == null) {
	      return new Error(__webpack_require__(13)('Required prop `%s` was not specified in `%s`.', propName, componentName));
	    } else if (!__webpack_require__(41)(component)) {
	      return new Error(__webpack_require__(13)('Invalid prop `%s` supplied to `%s`, expected a RelayContainer.', propName, componentName));
	    }
	    return null;
	  },
	  Environment: function Environment(props, propName, componentName) {
	    var context = props[propName];
	    if (!__webpack_require__(21)(context) || !__webpack_require__(30)(context)) {
	      return new Error(__webpack_require__(13)('Invalid prop/context `%s` supplied to `%s`, expected `%s` to be ' + 'an object conforming to the `RelayEnvironment` interface.', propName, componentName, context));
	    }
	    return null;
	  },


	  QueryConfig: __webpack_require__(18).shape({
	    name: __webpack_require__(18).string.isRequired,
	    params: __webpack_require__(18).object.isRequired,
	    queries: __webpack_require__(18).object.isRequired
	  }),

	  ClassicRelay: function ClassicRelay(props, propName, componentName) {
	    var relay = props[propName];
	    if (!__webpack_require__(5).isRelayContext(relay) || !__webpack_require__(21)(relay.environment)) {
	      return new Error(__webpack_require__(13)('Invalid prop/context `%s` supplied to `%s`, expected `%s` to be ' + 'an object with a classic `environment` implementation and `variables`.', propName, componentName, relay));
	    }
	    return null;
	  },
	  Relay: function Relay(props, propName, componentName) {
	    var relay = props[propName];
	    if (!__webpack_require__(5).isRelayContext(relay)) {
	      return new Error(__webpack_require__(13)('Invalid prop/context `%s` supplied to `%s`, expected `%s` to be ' + 'an object with an `environment` and `variables`.', propName, componentName, relay));
	    }
	    return null;
	  }
	};

	module.exports = RelayPropTypes;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_12__;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_13__;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var containerContextTypes = {
	  relay: __webpack_require__(11).Relay
	};

	/**
	 * `injectDefaultVariablesProvider()` allows classic versions of a container to
	 * inject default variable values for a fragment via the arguments of any
	 * references to it. This is useful for fragments that need to reference
	 * global query constants (e.g. the device pixel ratio) but may be included
	 * in classic queries that do not define the necessary param.
	 */
	var injectedDefaultVariablesProvider = null;
	function injectDefaultVariablesProvider(variablesProvider) {
	  !!injectedDefaultVariablesProvider ?  true ? __webpack_require__(1)(false, 'injectDefaultVariablesProvider must be called no more than once.') : require('fbjs/lib/invariant')(false) : void 0;
	  injectedDefaultVariablesProvider = variablesProvider;
	}

	/**
	 * Creates a component class whose instances adapt to the
	 * `context.relay.environment` in which they are rendered and which have the
	 * necessary static methods (`getFragment()` etc) to be composed within classic
	 * `Relay.Containers`.
	 *
	 * The returned constructor uses the given `createContainerForEnvironment` to
	 * construct a new container type whenever a new environment is encountered;
	 * while the constructor is being used for the same environment (the expected
	 * majority case) this value is memoized to avoid creating unnecessary extra
	 * container definitions or unwrapping the environment-specific fragment
	 * defintions unnecessarily.
	 */
	function buildCompatContainer(ComponentClass, fragmentSpec, createContainerWithFragments, providesChildContext) {
	  // Sanity-check user-defined fragment input
	  var containerName = __webpack_require__(6).getContainerName(ComponentClass);
	  __webpack_require__(28)(__webpack_require__(6).getComponentName(ComponentClass), fragmentSpec);

	  var injectedDefaultVariables = null;
	  function getDefaultVariables() {
	    if (injectedDefaultVariables == null) {
	      injectedDefaultVariables = injectedDefaultVariablesProvider ? injectedDefaultVariablesProvider() : {};
	    }
	    return injectedDefaultVariables;
	  }

	  // Similar to RelayContainer.getFragment(), except that this returns a
	  // FragmentSpread in order to support referencing root variables.
	  function getFragment(fragmentName, variableMapping) {
	    var taggedNode = fragmentSpec[fragmentName];
	    !taggedNode ?  true ? __webpack_require__(1)(false, 'ReactRelayCompatContainerBuilder: Expected a fragment named `%s` to be defined ' + 'on `%s`.', fragmentName, containerName) : require('fbjs/lib/invariant')(false) : void 0;
	    var fragment = __webpack_require__(25).getClassicFragment(taggedNode);

	    var args = (0, _extends3['default'])({}, getDefaultVariables(), variableMapping || {});

	    return {
	      kind: 'FragmentSpread',
	      args: args,
	      fragment: fragment
	    };
	  }

	  function hasVariable(variableName) {
	    return Object.keys(fragmentSpec).some(function (fragmentName) {
	      var fragment = __webpack_require__(25).getClassicFragment(fragmentSpec[fragmentName]);
	      return fragment.argumentDefinitions.some(function (argDef) {
	        return argDef.name === variableName;
	      });
	    });
	  }

	  // Memoize a container for the last environment instance encountered
	  var environment = void 0;
	  var Container = void 0;
	  function ContainerConstructor(props, context) {
	    if (Container == null || context.relay.environment !== environment) {
	      environment = context.relay.environment;
	      var getFragmentFromTag = environment.unstable_internal.getFragment;

	      var _fragments = __webpack_require__(31)(fragmentSpec, getFragmentFromTag);
	      Container = createContainerWithFragments(ComponentClass, _fragments);

	      // Attach static lifecycle to wrapper component so React can see it.
	      ContainerConstructor.getDerivedStateFromProps = Container.getDerivedStateFromProps;
	    }
	    // $FlowFixMe
	    return new Container(props, context);
	  }
	  ContainerConstructor.contextTypes = containerContextTypes;
	  if (providesChildContext) {
	    ContainerConstructor.childContextTypes = containerContextTypes;
	  }

	  function forwardRef(props, ref) {
	    return __webpack_require__(3).createElement(ContainerConstructor, (0, _extends3['default'])({}, props, {
	      componentRef: props.componentRef || ref
	    }));
	  }
	  forwardRef.displayName = containerName;
	  // $FlowFixMe
	  var ForwardContainer = __webpack_require__(3).forwardRef(forwardRef);

	  // Classic container static methods
	  ForwardContainer.getFragment = getFragment;
	  ForwardContainer.getFragmentNames = function () {
	    return Object.keys(fragmentSpec);
	  };
	  ForwardContainer.hasFragment = function (name) {
	    return fragmentSpec.hasOwnProperty(name);
	  };
	  ForwardContainer.hasVariable = hasVariable;

	  if (true) {
	    ForwardContainer.__ComponentClass = ComponentClass;
	  }

	  // Create a back-reference from the Component to the Container for cases
	  // where a Classic Component might refer to itself, expecting a Container.
	  ComponentClass.__container__ = ForwardContainer;

	  return ForwardContainer;
	}

	module.exports = { injectDefaultVariablesProvider: injectDefaultVariablesProvider, buildCompatContainer: buildCompatContainer };

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	function getRelayModernEnvironment(environment) {
	  if (__webpack_require__(2).isRelayModernEnvironment(environment)) {
	    return environment;
	  }
	}

	function getRelayClassicEnvironment(environment) {
	  if (__webpack_require__(21)(environment)) {
	    return environment;
	  }
	}

	module.exports = {
	  getRelayClassicEnvironment: getRelayClassicEnvironment,
	  getRelayModernEnvironment: getRelayModernEnvironment
	};

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_17__;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_18__;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	function profileContainer(Container, containerName) {
	  __webpack_require__(2).RelayProfiler.instrumentMethods(Container.prototype, {
	    constructor: containerName + '.prototype.constructor',
	    UNSAFE_componentWillReceiveProps: containerName + '.prototype.UNSAFE_componentWillReceiveProps',
	    componentWillUnmount: containerName + '.prototype.componentWillUnmount',
	    shouldComponentUpdate: containerName + '.prototype.shouldComponentUpdate'
	  });

	  // Copy static getDerivedStateFromProps() to the instrumented constructor.
	  // This is necessary to support the react-lifecycle-compat poyfill.
	  // This can be removed once react-relay requires React 16.3+.
	  if (Container.prototype !== null && typeof Container.prototype === 'object' && typeof Container.getDerivedStateFromProps === 'function') {
	    Container.prototype.constructor.getDerivedStateFromProps = Container.getDerivedStateFromProps;
	  }
	}

	module.exports = { profileContainer: profileContainer };

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var containerContextTypes = {
	  relay: __webpack_require__(11).Relay
	};

	/**
	 * Creates a component class whose instances adapt to the
	 * `context.relay.environment` in which they are rendered and which have the
	 * necessary static methods (`getFragment()` etc) to be composed within classic
	 * `Relay.Containers`.
	 */
	function buildReactRelayContainer(ComponentClass, fragmentSpec, createContainerWithFragments, providesChildContext) {
	  // Sanity-check user-defined fragment input
	  var containerName = __webpack_require__(6).getContainerName(ComponentClass);
	  __webpack_require__(28)(__webpack_require__(6).getComponentName(ComponentClass), fragmentSpec);

	  // Memoize a container for the last environment instance encountered
	  var environment = void 0;
	  var Container = void 0;
	  function ContainerConstructor(props, context) {
	    if (Container == null || context.relay.environment !== environment) {
	      environment = context.relay.environment;
	      if (true) {
	        var _require2 = __webpack_require__(2),
	            isRelayModernEnvironment = _require2.isRelayModernEnvironment;

	        if (!isRelayModernEnvironment(environment)) {
	          throw new Error('RelayModernContainer: Can only use Relay Modern component ' + (containerName + ' in a Relay Modern environment!\n') + 'When using Relay Modern and Relay Classic in the same ' + 'application, ensure components use Relay Compat to work in ' + 'both environments.\n' + 'See: http://facebook.github.io/relay/docs/relay-compat.html');
	        }
	      }
	      var getFragmentFromTag = environment.unstable_internal.getFragment;

	      var _fragments = __webpack_require__(31)(fragmentSpec, getFragmentFromTag);
	      Container = createContainerWithFragments(ComponentClass, _fragments);

	      // Attach static lifecycle to wrapper component so React can see it.
	      ContainerConstructor.getDerivedStateFromProps = Container.getDerivedStateFromProps;
	    }
	    // $FlowFixMe
	    return new Container(props, context);
	  }
	  ContainerConstructor.contextTypes = containerContextTypes;
	  if (providesChildContext) {
	    ContainerConstructor.childContextTypes = containerContextTypes;
	  }

	  function forwardRef(props, ref) {
	    return __webpack_require__(3).createElement(ContainerConstructor, (0, _extends3['default'])({}, props, {
	      componentRef: props.componentRef || ref
	    }));
	  }
	  forwardRef.displayName = containerName;
	  // $FlowFixMe
	  var ForwardContainer = __webpack_require__(3).forwardRef(forwardRef);

	  if (true) {
	    ForwardContainer.__ComponentClass = ComponentClass;
	    // Classic container static methods.
	    ForwardContainer.getFragment = function getFragmentOnModernContainer() {
	      throw new Error('RelayModernContainer: ' + containerName + '.getFragment() was called on ' + 'a Relay Modern component by a Relay Classic or Relay Compat ' + 'component.\n' + 'When using Relay Modern and Relay Classic in the same ' + 'application, ensure components use Relay Compat to work in ' + 'both environments.\n' + 'See: http://facebook.github.io/relay/docs/relay-compat.html');
	    };
	  }

	  return ForwardContainer;
	}

	module.exports = buildReactRelayContainer;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	/**
	 * Determine if a given value is an object that implements the `RelayEnvironment`
	 * interface.
	 */

	function isClassicRelayEnvironment(environment) {
	  return typeof environment === 'object' && environment !== null && typeof environment.applyMutation === 'function' && typeof environment.sendMutation === 'function' && typeof environment.forceFetch === 'function' && typeof environment.getFragmentResolver === 'function' && typeof environment.getStoreData === 'function' && typeof environment.primeCache === 'function';
	}

	module.exports = isClassicRelayEnvironment;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_22__;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var RelayCompatMutations = {
	  commitUpdate: function commitUpdate(environment, config) {
	    var relayStaticEnvironment = __webpack_require__(15).getRelayModernEnvironment(environment);
	    if (relayStaticEnvironment) {
	      return __webpack_require__(2).commitMutation(relayStaticEnvironment, config);
	    } else {
	      var relayClassicEnvironment = __webpack_require__(15).getRelayClassicEnvironment(environment);
	      !relayClassicEnvironment ?  true ? __webpack_require__(1)(false, 'RelayCompatMutations: Expected an object that conforms to the ' + '`RelayEnvironmentInterface`, got `%s`.', environment) : require('fbjs/lib/invariant')(false) : void 0;
	      return commitRelayClassicMutation(
	      // getRelayClassicEnvironment returns a RelayEnvironmentInterface
	      // (classic APIs), but we need the modern APIs on old core here.
	      relayClassicEnvironment, config);
	    }
	  },
	  applyUpdate: function applyUpdate(environment, config) {
	    var relayStaticEnvironment = __webpack_require__(15).getRelayModernEnvironment(environment);
	    if (relayStaticEnvironment) {
	      return __webpack_require__(2).applyOptimisticMutation(relayStaticEnvironment, config);
	    } else {
	      var relayClassicEnvironment = __webpack_require__(15).getRelayClassicEnvironment(environment);
	      !relayClassicEnvironment ?  true ? __webpack_require__(1)(false, 'RelayCompatMutations: Expected an object that conforms to the ' + '`RelayEnvironmentInterface`, got `%s`.', environment) : require('fbjs/lib/invariant')(false) : void 0;
	      return applyRelayClassicMutation(
	      // getRelayClassicEnvironment returns a RelayEnvironmentInterface
	      // (classic APIs), but we need the modern APIs on old core here.
	      relayClassicEnvironment, config);
	    }
	  }
	};

	function commitRelayClassicMutation(environment, _ref) {
	  var configs = _ref.configs,
	      mutation = _ref.mutation,
	      onCompleted = _ref.onCompleted,
	      onError = _ref.onError,
	      optimisticResponse = _ref.optimisticResponse,
	      variables = _ref.variables,
	      uploadables = _ref.uploadables;
	  var getRequest = environment.unstable_internal.getRequest;

	  var operation = getRequest(mutation);
	  // TODO: remove this check after we fix flow.
	  if (typeof optimisticResponse === 'function') {
	     true ? __webpack_require__(8)(false, 'RelayCompatMutations: Expected `optimisticResponse` to be an object, ' + 'received a function.') : void 0;
	    optimisticResponse = optimisticResponse();
	  }
	  if (optimisticResponse) {
	    optimisticResponse = validateOptimisticResponse(operation, optimisticResponse);
	  }

	  return environment.sendMutation({
	    configs: configs || [],
	    operation: operation,
	    onCompleted: onCompleted,
	    onError: onError,
	    optimisticResponse: optimisticResponse,
	    variables: variables,
	    uploadables: uploadables
	  });
	}

	function applyRelayClassicMutation(environment, _ref2) {
	  var configs = _ref2.configs,
	      mutation = _ref2.mutation,
	      optimisticResponse = _ref2.optimisticResponse,
	      variables = _ref2.variables;
	  var getRequest = environment.unstable_internal.getRequest;

	  var operation = getRequest(mutation);
	  if (operation.operation !== 'mutation') {
	    throw new Error('RelayCompatMutations: Expected mutation operation');
	  }

	  // RelayClassic can't update anything without response.
	  if (!optimisticResponse) {
	    return { dispose: function dispose() {} };
	  }

	  optimisticResponse = validateOptimisticResponse(operation, optimisticResponse);
	  return environment.applyMutation({
	    configs: configs || [],
	    operation: operation,
	    optimisticResponse: optimisticResponse,
	    variables: variables
	  });
	}

	function validateOptimisticResponse(operation, optimisticResponse) {
	  if (operation.node.kind === 'Mutation' && operation.node.calls && operation.node.calls.length === 1) {
	    var mutationRoot = operation.node.calls[0].name;
	    if (optimisticResponse[mutationRoot]) {
	      return optimisticResponse[mutationRoot];
	    } else {
	       true ? __webpack_require__(8)(false, 'RelayCompatMutations: Expected result from `optimisticResponse`' + 'to contain the mutation name `%s` as a property, got `%s`', mutationRoot, optimisticResponse) : void 0;
	    }
	  }
	  return optimisticResponse;
	}

	module.exports = RelayCompatMutations;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * @internal
	 *
	 * RelayFragmentReference is the return type of fragment composition:
	 *
	 *   fragment on Foo {
	 *     ${Child.getFragment('bar', {baz: variables.qux})}
	 *   }
	 *
	 * Whereas a fragment defines a sub-query's structure, a fragment reference is
	 * a particular instantiation of the fragment as it is composed within a query
	 * or another fragment. It encodes the source fragment, initial variables, and
	 * a mapping from variables in the composing query's (or fragment's) scope to
	 * variables in the fragment's scope.
	 *
	 * The variable mapping is represented by `variableMapping`, a dictionary that
	 * maps from names of variables in the parent scope to variables that exist in
	 * the fragment. Example:
	 *
	 * ```
	 * // Fragment:
	 * var Container = Relay.createContainer(..., {
	 *   initialVariables: {
	 *     private: 'foo',
	 *     public: 'bar',
	 *     variable: null,
	 *   },
	 *   fragments: {
	 *     foo: ...
	 *   }
	 * });
	 *
	 * // Reference:
	 * ${Container.getQuery(
	 *   'foo',
	 *   // Variable Mapping:
	 *   {
	 *     public: 'BAR',
	 *     variable: variables.source,
	 *   }
	 * )}
	 * ```
	 *
	 * When evaluating the referenced fragment, `$public` will be overridden with
	 * `'Bar'`. The value of `$variable` will become the value of `$source` in the
	 * outer scope. This is analagous to:
	 *
	 * ```
	 * function inner(private = 'foo', public = 'bar', variable) {}
	 * function outer(source) {
	 *   inner(public = 'BAR', variable = source);
	 * }
	 * ```
	 *
	 * Where the value of the inner `variable` depends on how `outer` is called.
	 *
	 * The `prepareVariables` function allows for variables to be modified based on
	 * the runtime environment or route name.
	 */
	var RelayFragmentReference = function () {
	  RelayFragmentReference.createForContainer = function createForContainer(fragmentGetter, initialVariables, variableMapping, prepareVariables) {
	    var reference = new RelayFragmentReference(fragmentGetter, initialVariables, variableMapping, prepareVariables);
	    reference._isContainerFragment = true;
	    return reference;
	  };

	  function RelayFragmentReference(fragmentGetter, initialVariables, variableMapping, prepareVariables) {
	    (0, _classCallCheck3['default'])(this, RelayFragmentReference);

	    this._conditions = null;
	    this._initialVariables = initialVariables || {};
	    this._fragment = undefined;
	    this._fragmentGetter = fragmentGetter;
	    this._isContainerFragment = false;
	    this._isDeferred = false;
	    this._isTypeConditional = false;
	    this._variableMapping = variableMapping;
	    this._prepareVariables = prepareVariables;
	  }

	  RelayFragmentReference.prototype.conditionOnType = function conditionOnType() {
	    this._isTypeConditional = true;
	    return this;
	  };

	  RelayFragmentReference.prototype.getConditions = function getConditions() {
	    return this._conditions;
	  };

	  RelayFragmentReference.prototype.getFragmentUnconditional = function getFragmentUnconditional() {
	    var fragment = this._fragment;
	    if (fragment == null) {
	      fragment = this._fragmentGetter();
	      this._fragment = fragment;
	    }
	    return fragment;
	  };

	  RelayFragmentReference.prototype.getInitialVariables = function getInitialVariables() {
	    return this._initialVariables;
	  };

	  RelayFragmentReference.prototype.getVariableMapping = function getVariableMapping() {
	    return this._variableMapping;
	  };

	  /**
	   * Mark this usage of the fragment as deferred.
	   */


	  RelayFragmentReference.prototype.defer = function defer() {
	    this._isDeferred = true;
	    return this;
	  };

	  /**
	   * Mark this fragment for inclusion only if the given variable is truthy.
	   */


	  RelayFragmentReference.prototype['if'] = function _if(value) {
	    var callVariable = __webpack_require__(4).getCallVariable(value);
	    !callVariable ?  true ? __webpack_require__(1)(false, 'RelayFragmentReference: Invalid value `%s` supplied to `if()`. ' + 'Expected a variable.', callVariable) : require('fbjs/lib/invariant')(false) : void 0;
	    this._addCondition({
	      passingValue: true,
	      variable: callVariable.callVariableName
	    });
	    return this;
	  };

	  /**
	   * Mark this fragment for inclusion only if the given variable is falsy.
	   */


	  RelayFragmentReference.prototype.unless = function unless(value) {
	    var callVariable = __webpack_require__(4).getCallVariable(value);
	    !callVariable ?  true ? __webpack_require__(1)(false, 'RelayFragmentReference: Invalid value `%s` supplied to `unless()`. ' + 'Expected a variable.', callVariable) : require('fbjs/lib/invariant')(false) : void 0;
	    this._addCondition({
	      passingValue: false,
	      variable: callVariable.callVariableName
	    });
	    return this;
	  };

	  /**
	   * Get the referenced fragment if all conditions are met.
	   */


	  RelayFragmentReference.prototype.getFragment = function getFragment(variables) {
	    // determine if the variables match the supplied if/unless conditions
	    var conditions = this._conditions;
	    if (conditions && !conditions.every(function (_ref) {
	      var variable = _ref.variable,
	          passingValue = _ref.passingValue;

	      return !!variables[variable] === passingValue;
	    })) {
	      return null;
	    }
	    return this.getFragmentUnconditional();
	  };

	  /**
	   * Get the variables to pass to the referenced fragment, accounting for
	   * initial values, overrides, and route-specific variables.
	   */


	  RelayFragmentReference.prototype.getVariables = function getVariables(route, variables) {
	    var _this = this;

	    var innerVariables = (0, _extends3['default'])({}, this._initialVariables);

	    // map variables from outer -> inner scope
	    var variableMapping = this._variableMapping;
	    if (variableMapping) {
	      __webpack_require__(46)(variableMapping, function (value, name) {
	        var callVariable = __webpack_require__(4).getCallVariable(value);
	        if (callVariable) {
	          value = variables[callVariable.callVariableName];
	        }
	        if (value === undefined) {
	           true ? __webpack_require__(8)(false, 'RelayFragmentReference: Variable `%s` is undefined in fragment ' + '`%s`.', name, _this.getFragmentUnconditional().name) : void 0;
	        } else {
	          innerVariables[name] = value;
	        }
	      });
	    }

	    var prepareVariables = this._prepareVariables;
	    if (prepareVariables) {
	      innerVariables = prepareVariables(innerVariables, route);
	    }

	    return innerVariables;
	  };

	  RelayFragmentReference.prototype.isContainerFragment = function isContainerFragment() {
	    return this._isContainerFragment;
	  };

	  RelayFragmentReference.prototype.isDeferred = function isDeferred() {
	    return this._isDeferred;
	  };

	  RelayFragmentReference.prototype.isTypeConditional = function isTypeConditional() {
	    return this._isTypeConditional;
	  };

	  RelayFragmentReference.prototype._addCondition = function _addCondition(condition) {
	    var conditions = this._conditions;
	    if (!conditions) {
	      conditions = [];
	      this._conditions = conditions;
	    }
	    conditions.push(condition);
	  };

	  return RelayFragmentReference;
	}();

	module.exports = RelayFragmentReference;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	/**
	 * Runtime function to correspond to the `graphql` tagged template function.
	 * All calls to this function should be transformed by the plugin.
	 */
	function graphql() {
	   true ?  true ? __webpack_require__(1)(false, 'graphql: Unexpected invocation at runtime. Either the Babel transform ' + 'was not set up, or it failed to identify this call site. Make sure it ' + 'is being used verbatim as `graphql`.') : require('fbjs/lib/invariant')(false) : void 0;
	}

	function getClassicFragment(taggedNode) {
	  return __webpack_require__(27).__getClassicFragment(taggedNode);
	}

	function getClassicOperation(taggedNode) {
	  return __webpack_require__(27).__getClassicOperation(taggedNode);
	}

	module.exports = {
	  getClassicFragment: getClassicFragment,
	  getClassicOperation: getClassicOperation,
	  graphql: graphql
	};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var getResultsFromPayloadImpl = getResultsFromPayload;

	/**
	 * @internal
	 *
	 * Defines logic relevant to the informal "Node" GraphQL interface.
	 */
	var RelayNodeInterface = {
	  ANY_TYPE: '__any',
	  ID: 'id',
	  ID_TYPE: 'ID!',
	  NODE: 'node',
	  NODE_TYPE: 'Node',
	  NODES: 'nodes',
	  TYPENAME: '__typename',

	  isNodeRootCall: function isNodeRootCall(fieldName) {
	    return fieldName === RelayNodeInterface.NODE || fieldName === RelayNodeInterface.NODES;
	  },
	  getResultsFromPayload: function getResultsFromPayload(query, payload) {
	    return getResultsFromPayloadImpl(query, payload);
	  },


	  /**
	   * Allow for injecting custom behavior for getResultsFromPayload.
	   */
	  injectGetResultsFromPayloadImpl: function injectGetResultsFromPayloadImpl(impl) {
	    getResultsFromPayloadImpl = impl;
	  }
	};

	function getResultsFromPayload(query, payload) {
	  var results = [];

	  var rootBatchCall = query.getBatchCall();
	  if (rootBatchCall) {
	    getPayloadRecords(query, payload).forEach(function (result) {
	      if (typeof result !== 'object' || !result) {
	        return;
	      }
	      var dataID = result[RelayNodeInterface.ID];
	      !(typeof dataID === 'string') ?  true ? __webpack_require__(1)(false, 'RelayNodeInterface.getResultsFromPayload(): Unable to write ' + 'result with no `%s` field for query, `%s`.', RelayNodeInterface.ID, query.getName()) : require('fbjs/lib/invariant')(false) : void 0;
	      results.push({
	        result: result,
	        rootCallInfo: {
	          storageKey: RelayNodeInterface.NODE,
	          identifyingArgKey: dataID,
	          identifyingArgValue: dataID
	        }
	      });
	    });
	  } else {
	    var records = getPayloadRecords(query, payload);
	    var ii = 0;
	    var _storageKey = query.getStorageKey();
	    __webpack_require__(40)(query, function (_ref) {
	      var identifyingArgKey = _ref.identifyingArgKey,
	          identifyingArgValue = _ref.identifyingArgValue;

	      var result = records[ii++];
	      results.push({
	        result: result,
	        rootCallInfo: { storageKey: _storageKey, identifyingArgKey: identifyingArgKey, identifyingArgValue: identifyingArgValue }
	      });
	    });
	  }

	  return results;
	}

	function getPayloadRecords(query, payload) {
	  var fieldName = query.getFieldName();
	  var identifyingArg = query.getIdentifyingArg();
	  var identifyingArgValue = identifyingArg && identifyingArg.value || null;
	  var records = payload[fieldName];
	  if (!query.getBatchCall()) {
	    if (Array.isArray(identifyingArgValue)) {
	      !Array.isArray(records) ?  true ? __webpack_require__(1)(false, 'RelayNodeInterface: Expected payload for root field `%s` to be ' + 'an array with %s results, instead received a single non-array result.', fieldName, identifyingArgValue.length) : require('fbjs/lib/invariant')(false) : void 0;
	      !(records.length === identifyingArgValue.length) ?  true ? __webpack_require__(1)(false, 'RelayNodeInterface: Expected payload for root field `%s` to be ' + 'an array with %s results, instead received an array with %s results.', fieldName, identifyingArgValue.length, records.length) : require('fbjs/lib/invariant')(false) : void 0;
	    } else if (Array.isArray(records)) {
	       true ?  true ? __webpack_require__(1)(false, 'RelayNodeInterface: Expected payload for root field `%s` to be ' + 'a single non-array result, instead received an array with %s results.', fieldName, records.length) : require('fbjs/lib/invariant')(false) : void 0;
	    }
	  }
	  return Array.isArray(records) ? records : [records || null];
	}

	module.exports = RelayNodeInterface;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * @public
	 *
	 * This is a tag function used with template strings to provide the facade of a
	 * runtime GraphQL parser. Example usage:
	 *
	 *   Relay.QL`fragment on User { name }`
	 *
	 * In actuality, a Babel transform parses these tag templates and replaces it
	 * with an internal representation of the query structure.
	 */
	function RelayQL(strings) {
	   true ?  true ? __webpack_require__(1)(false, 'RelayQL: Unexpected invocation at runtime. Either the Babel transform ' + 'was not set up, or it failed to identify this call site. Make sure it ' + 'is being used verbatim as `Relay.QL`.') : require('fbjs/lib/invariant')(false) : void 0;
	}

	function assertValidFragment(substitution) {
	  !(substitution instanceof __webpack_require__(24) || __webpack_require__(4).getFragment(substitution) || __webpack_require__(4).getFragmentSpread(substitution)) ?  true ? __webpack_require__(1)(false, 'RelayQL: Invalid fragment composition, use ' + "`${Child.getFragment('name')}`.") : require('fbjs/lib/invariant')(false) : void 0;
	}

	var CLASSIC_NODE = '__classic_node__';

	/**
	 * Private helper methods used by the transformed code.
	 */
	Object.assign(RelayQL, {
	  __frag: function __frag(substitution) {
	    if (typeof substitution === 'function') {
	      // Route conditional fragment, e.g. `${route => matchRoute(route, ...)}`.
	      return new (__webpack_require__(39))(substitution);
	    }
	    if (substitution != null) {
	      if (Array.isArray(substitution)) {
	        substitution.forEach(assertValidFragment);
	      } else {
	        assertValidFragment(substitution);
	      }
	    }
	    return substitution;
	  },
	  __var: function __var(expression) {
	    var variable = __webpack_require__(4).getCallVariable(expression);
	    if (variable) {
	       true ?  true ? __webpack_require__(1)(false, 'RelayQL: Invalid argument `%s` supplied via template substitution. ' + 'Instead, use an inline variable (e.g. `comments(count: $count)`).', variable.callVariableName) : require('fbjs/lib/invariant')(false) : void 0;
	    }
	    return __webpack_require__(4).createCallValue(expression);
	  },
	  __id: function __id() {
	    return __webpack_require__(29)();
	  },
	  __createFragment: function __createFragment(fragment, variableMapping) {
	    return new (__webpack_require__(24))(function () {
	      return fragment;
	    }, null, variableMapping);
	  },


	  /**
	   * Memoizes the results of executing the `.classic()` functions on
	   * graphql`...` tagged expressions. Memoization allows the framework to use
	   * object equality checks to compare fragments (useful, for example, when
	   * comparing two `Selector`s to see if they select the same data).
	   */
	  __getClassicNode: function __getClassicNode(taggedNode) {
	    var concreteNode = taggedNode[CLASSIC_NODE];
	    if (concreteNode == null) {
	      var fn = taggedNode.classic;
	      !(typeof fn === 'function') ?  true ? __webpack_require__(1)(false, 'RelayQL: Expected a graphql literal, got `%s`.\n' + 'The "relay" Babel plugin must enable "compat" mode to be used with ' + '"react-relay/compat" or "react-relay/classic".\n' + 'See: https://facebook.github.io/relay/docs/babel-plugin-relay.html', JSON.stringify(taggedNode)) : require('fbjs/lib/invariant')(false) : void 0;
	      concreteNode = fn(this);
	      taggedNode[CLASSIC_NODE] = concreteNode;
	    }
	    return concreteNode;
	  },
	  __getClassicFragment: function __getClassicFragment(taggedNode, isUnMasked) {
	    var concreteNode = this.__getClassicNode(taggedNode);
	    var fragment = __webpack_require__(4).getFragmentDefinition(concreteNode);
	    !fragment ?  true ? __webpack_require__(1)(false, 'RelayQL: Expected a fragment, got `%s`.\n' + 'The "relay" Babel plugin must enable "compat" mode to be used with ' + '"react-relay/compat" or "react-relay/classic".\n' + 'See: https://facebook.github.io/relay/docs/babel-plugin-relay.html', concreteNode) : require('fbjs/lib/invariant')(false) : void 0;
	    if (isUnMasked) {
	      /*
	       * For a regular `Fragment` or `Field` node, its variables have been declared
	       * in the parent. However, since unmasked fragment is actually parsed as `FragmentSpread`,
	       * we need to manually hoist its arguments to the parent.
	       * In reality, we do not actually hoist the arguments because Babel transform is per file.
	       * Instead, we could put the `argumentDefinitions` in the `metadata` and resolve the variables
	       * when building the concrete fragment node.
	       */
	      var hoistedRootArgs = [];
	      fragment.argumentDefinitions.forEach(function (argDef) {
	        !(argDef.kind === 'RootArgument') ?  true ? __webpack_require__(1)(false, 'RelayQL: Cannot unmask fragment `%s`. Expected all the arguments are root argument' + ' but get `%s`', concreteNode.node.name, argDef.name) : require('fbjs/lib/invariant')(false) : void 0;
	        hoistedRootArgs.push(argDef.name);
	      });

	      fragment.node.metadata = (0, _extends3['default'])({}, concreteNode.node.metadata, {
	        hoistedRootArgs: hoistedRootArgs
	      });
	    }
	    return fragment;
	  },
	  __getClassicOperation: function __getClassicOperation(taggedNode) {
	    var concreteNode = this.__getClassicNode(taggedNode);
	    var operation = __webpack_require__(4).getOperationDefinition(concreteNode);
	    !operation ?  true ? __webpack_require__(1)(false, 'RelayQL: Expected an operation, got `%s`.\n' + 'The "relay" Babel plugin must enable "compat" mode to be used with ' + '"react-relay/compat" or "react-relay/classic".\n' + 'See: https://facebook.github.io/relay/docs/babel-plugin-relay.html', concreteNode) : require('fbjs/lib/invariant')(false) : void 0;
	    return operation;
	  }
	});

	module.exports = RelayQL;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	/**
	 * Fail fast if the user supplies invalid fragments as input.
	 */
	function assertFragmentMap(componentName, fragments) {
	  !(fragments && typeof fragments === 'object') ?  true ? __webpack_require__(1)(false, 'Could not create Relay Container for `%s`. ' + 'Expected a set of GraphQL fragments, got `%s` instead.', componentName, fragments) : require('fbjs/lib/invariant')(false) : void 0;

	  for (var key in fragments) {
	    if (fragments.hasOwnProperty(key)) {
	      var fragment = fragments[key];
	      !(fragment && (typeof fragment === 'object' || typeof fragment === 'function')) ?  true ? __webpack_require__(1)(false, 'Could not create Relay Container for `%s`. ' + 'The value of fragment `%s` was expected to be a fragment, got `%s` instead.', componentName, key, fragment) : require('fbjs/lib/invariant')(false) : void 0;
	    }
	  }
	}

	module.exports = assertFragmentMap;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	// Static ids always end with `:<HASH>` where HASH is an alphanumeric transform
	// of an auto-incrementing index. A double-colon is used to distinguish between
	// client ids and static ids that happen to hash to `:client`.
	var SUFFIX = '::client';

	var _nextFragmentID = 0;

	/**
	 * The "concrete fragment id" uniquely identifies a Relay.QL`fragment ...`
	 * within the source code of an application and will remain the same across
	 * runs of a particular version of an application.
	 *
	 * This function can be used to generate a unique id for fragments constructed
	 * at runtime and is guaranteed not to conflict with statically created ids.
	 */
	function generateConcreteFragmentID() {
	  return __webpack_require__(45)(_nextFragmentID++) + SUFFIX;
	}

	module.exports = generateConcreteFragmentID;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	/**
	 * Determine if a given value is an object that implements the `Environment`
	 * interface defined in `RelayEnvironmentTypes`.
	 */

	function isRelayEnvironment(environment) {
	  return typeof environment === 'object' && environment !== null &&
	  // TODO: add applyMutation/sendMutation once ready in both cores
	  typeof environment.check === 'function' && typeof environment.lookup === 'function' && typeof environment.retain === 'function' && typeof environment.sendQuery === 'function' && typeof environment.execute === 'function' && typeof environment.subscribe === 'function';
	}

	module.exports = isRelayEnvironment;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_31__;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _objectWithoutProperties3 = _interopRequireDefault(__webpack_require__(22));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	var _possibleConstructorReturn3 = _interopRequireDefault(__webpack_require__(17));

	var _inherits3 = _interopRequireDefault(__webpack_require__(16));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * Composes a React component class, returning a new class that intercepts
	 * props, resolving them with the provided fragments and subscribing for
	 * updates.
	 */
	function createContainerWithFragments(Component, fragments) {
	  var containerName = __webpack_require__(6).getContainerName(Component);

	  var Container = function (_React$Component) {
	    (0, _inherits3['default'])(Container, _React$Component);

	    function Container(props, context) {
	      (0, _classCallCheck3['default'])(this, Container);

	      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));

	      _this._handleFragmentDataUpdate = function () {
	        var profiler = __webpack_require__(2).RelayProfiler.profile('ReactRelayFragmentContainer.handleFragmentDataUpdate');
	        var resolverFromThisUpdate = _this.state.resolver;
	        _this.setState(function (updatedState) {
	          // If this event belongs to the current data source, update.
	          // Otherwise we should ignore it.
	          if (resolverFromThisUpdate === updatedState.resolver) {
	            return {
	              data: updatedState.resolver.resolve(),
	              relayProp: {
	                isLoading: updatedState.resolver.isLoading(),
	                environment: updatedState.relayProp.environment
	              }
	            };
	          }

	          return null;
	        }, profiler.stop);
	      };

	      var relay = __webpack_require__(5).assertRelayContext(context.relay);
	      var createFragmentSpecResolver = relay.environment.unstable_internal.createFragmentSpecResolver;
	      // Do not provide a subscription/callback here.
	      // It is possible for this render to be interrupted or aborted,
	      // In which case the subscription would cause a leak.
	      // We will add the subscription in componentDidMount().

	      var resolver = createFragmentSpecResolver(relay, containerName, fragments, props);
	      _this.state = {
	        data: resolver.resolve(),
	        relay: relay,
	        relayEnvironment: context.relay.environment,
	        prevProps: _this.props,
	        relayVariables: context.relay.variables,
	        relayProp: {
	          isLoading: resolver.isLoading(),
	          environment: relay.environment
	        },
	        resolver: resolver
	      };
	      return _this;
	    }

	    /**
	     * When new props are received, read data for the new props and subscribe
	     * for updates. Props may be the same in which case previous data and
	     * subscriptions can be reused.
	     */


	    Container.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
	      // Any props change could impact the query, so we mirror props in state.
	      // This is an unusual pattern, but necessary for this container usecase.
	      var prevProps = prevState.prevProps,
	          relay = prevState.relay;
	      var _relay$environment$un = relay.environment.unstable_internal,
	          createFragmentSpecResolver = _relay$environment$un.createFragmentSpecResolver,
	          getDataIDsFromObject = _relay$environment$un.getDataIDsFromObject;

	      var prevIDs = getDataIDsFromObject(fragments, prevProps);
	      var nextIDs = getDataIDsFromObject(fragments, nextProps);

	      var resolver = prevState.resolver;

	      // If the environment has changed or props point to new records then
	      // previously fetched data and any pending fetches no longer apply:
	      // - Existing references are on the old environment.
	      // - Existing references are based on old variables.
	      // - Pending fetches are for the previous records.
	      if (prevState.relayEnvironment !== relay.environment || prevState.relayVariables !== relay.variables || !__webpack_require__(12)(prevIDs, nextIDs)) {
	        // Do not provide a subscription/callback here.
	        // It is possible for this render to be interrupted or aborted,
	        // In which case the subscription would cause a leak.
	        // We will add the subscription in componentDidUpdate().
	        resolver = createFragmentSpecResolver(relay, containerName, fragments, nextProps);

	        return {
	          data: resolver.resolve(),
	          relayEnvironment: relay.environment,
	          prevProps: nextProps,
	          relayVariables: relay.variables,
	          relayProp: {
	            isLoading: resolver.isLoading(),
	            environment: relay.environment
	          },
	          resolver: resolver
	        };
	      } else {
	        resolver.setProps(nextProps);

	        var _data = resolver.resolve();
	        if (_data !== prevState.data) {
	          return {
	            data: _data,
	            relayEnvironment: relay.environment,
	            prevProps: nextProps,
	            relayVariables: relay.variables,
	            relayProp: {
	              isLoading: resolver.isLoading(),
	              environment: relay.environment
	            }
	          };
	        }
	      }

	      return null;
	    };

	    Container.prototype.componentDidMount = function componentDidMount() {
	      this._subscribeToNewResolver();
	      this._rerenderIfStoreHasChanged();
	    };

	    Container.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
	      if (this.state.resolver !== prevState.resolver) {
	        prevState.resolver.dispose();

	        this._subscribeToNewResolver();
	      }
	      this._rerenderIfStoreHasChanged();
	    };

	    Container.prototype.componentWillUnmount = function componentWillUnmount() {
	      this.state.resolver.dispose();
	    };

	    Container.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	      // Short-circuit if any Relay-related data has changed
	      if (nextState.data !== this.state.data) {
	        return true;
	      }
	      // Otherwise, for convenience short-circuit if all non-Relay props
	      // are scalar and equal
	      var keys = Object.keys(nextProps);
	      for (var ii = 0; ii < keys.length; ii++) {
	        var _key = keys[ii];
	        if (_key === 'relay') {
	          if (nextState.relayEnvironment !== this.state.relayEnvironment || nextState.relayVariables !== this.state.relayVariables) {
	            return true;
	          }
	        } else {
	          if (!fragments.hasOwnProperty(_key) && !__webpack_require__(2).isScalarAndEqual(nextProps[_key], this.props[_key])) {
	            return true;
	          }
	        }
	      }
	      return false;
	    };

	    /**
	     * Render new data for the existing props/context.
	     */


	    Container.prototype._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
	      var _state = this.state,
	          data = _state.data,
	          resolver = _state.resolver;
	      // External values could change between render and commit.
	      // Check for this case, even though it requires an extra store read.

	      var maybeNewData = resolver.resolve();
	      if (data !== maybeNewData) {
	        this.setState({ data: maybeNewData });
	      }
	    };

	    Container.prototype._subscribeToNewResolver = function _subscribeToNewResolver() {
	      var resolver = this.state.resolver;

	      // Event listeners are only safe to add during the commit phase,
	      // So they won't leak if render is interrupted or errors.

	      resolver.setCallback(this._handleFragmentDataUpdate);
	    };

	    Container.prototype.render = function render() {
	      var _props = this.props,
	          componentRef = _props.componentRef,
	          props = (0, _objectWithoutProperties3['default'])(_props, ['componentRef']);

	      return __webpack_require__(3).createElement(Component, (0, _extends3['default'])({}, props, this.state.data, {
	        ref: componentRef,
	        relay: this.state.relayProp
	      }));
	    };

	    return Container;
	  }(__webpack_require__(3).Component);

	  Container.displayName = containerName;
	  Container.contextTypes = {
	    relay: __webpack_require__(11).Relay
	  };

	  __webpack_require__(19).profileContainer(Container, 'ReactRelayFragmentContainer');

	  return Container;
	}

	/**
	 * Wrap the basic `createContainer()` function with logic to adapt to the
	 * `context.relay.environment` in which it is rendered. Specifically, the
	 * extraction of the environment-specific version of fragments in the
	 * `fragmentSpec` is memoized once per environment, rather than once per
	 * instance of the container constructed/rendered.
	 */
	function createContainer(Component, fragmentSpec) {
	  return __webpack_require__(20)(Component, fragmentSpec, createContainerWithFragments,
	  /* provides child context */false);
	}

	module.exports = { createContainer: createContainer, createContainerWithFragments: createContainerWithFragments };

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _objectWithoutProperties3 = _interopRequireDefault(__webpack_require__(22));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	var _possibleConstructorReturn3 = _interopRequireDefault(__webpack_require__(17));

	var _inherits3 = _interopRequireDefault(__webpack_require__(16));

	var _defineProperty3 = _interopRequireDefault(__webpack_require__(44));

	var _extends4 = _interopRequireDefault(__webpack_require__(7));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var containerContextTypes = {
	  relay: __webpack_require__(11).Relay
	};

	var FORWARD = 'forward';

	/**
	 * Extends the functionality of RelayFragmentContainer by providing a mechanism
	 * to load more data from a connection.
	 *
	 * # Configuring a PaginationContainer
	 *
	 * PaginationContainer accepts the standard FragmentContainer arguments and an
	 * additional `connectionConfig` argument:
	 *
	 * - `Component`: the component to be wrapped/rendered.
	 * - `fragments`: an object whose values are `graphql` fragments. The object
	 *   keys determine the prop names by which fragment data is available.
	 * - `connectionConfig`: an object that determines how to load more connection
	 *   data. Details below.
	 *
	 * # Loading More Data
	 *
	 * Use `props.relay.hasMore()` to determine if there are more items to load.
	 *
	 * ```
	 * hasMore(): boolean
	 * ```
	 *
	 * Use `props.relay.isLoading()` to determine if a previous call to `loadMore()`
	 * is still pending. This is convenient for avoiding duplicate load calls.
	 *
	 * ```
	 * isLoading(): boolean
	 * ```
	 *
	 * Use `props.relay.loadMore()` to load more items. This will return null if
	 * there are no more items to fetch, otherwise it will fetch more items and
	 * return a Disposable that can be used to cancel the fetch.
	 *
	 * `pageSize` should be the number of *additional* items to fetch (not the
	 * total).
	 *
	 * ```
	 * loadMore(pageSize: number, callback: ?(error: ?Error) => void): ?Disposable
	 * ```
	 *
	 * A complete example:
	 *
	 * ```
	 * class Foo extends React.Component {
	 *   ...
	 *   _onEndReached() {
	 *     if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {
	 *       return;
	 *     }
	 *     this.props.relay.loadMore(10);
	 *   }
	 *   ...
	 * }
	 * ```
	 *
	 * # Connection Config
	 *
	 * Here's an example, followed by details of each config property:
	 *
	 * ```
	 * ReactRelayPaginationContainer.createContainer(
	 *   Component,
	 *   {
	 *     user: graphql`fragment FriendsFragment on User {
	 *       friends(after: $afterCursor first: $count) @connection {
	 *         edges { ... }
	 *         pageInfo {
	 *           startCursor
	 *           endCursor
	 *           hasNextPage
	 *           hasPreviousPage
	 *         }
	 *       }
	 *     }`,
	 *   },
	 *   {
	 *     direction: 'forward',
	 *     getConnectionFromProps(props) {
	 *       return props.user && props.user.friends;
	 *     },
	 *     getFragmentVariables(vars, totalCount) {
	 *       // The component presumably wants *all* edges, not just those after
	 *       // the cursor, so notice that we don't set $afterCursor here.
	 *       return {
	 *         ...vars,
	 *         count: totalCount,
	 *       };
	 *     },
	 *     getVariables(props, {count, cursor}, fragmentVariables) {
	 *       return {
	 *         id: props.user.id,
	 *         afterCursor: cursor,
	 *         count,
	 *       },
	 *     },
	 *     query: graphql`
	 *       query FriendsQuery($id: ID!, $afterCursor: ID, $count: Int!) {
	 *         node(id: $id) {
	 *           ...FriendsFragment
	 *         }
	 *       }
	 *     `,
	 *   }
	 * );
	 * ```
	 *
	 * ## Config Properties
	 *
	 * - `direction`: Either "forward" to indicate forward pagination using
	 *   after/first, or "backward" to indicate backward pagination using
	 *   before/last.
	 * - `getConnectionFromProps(props)`: PaginationContainer doesn't magically know
	 *   which connection data you mean to fetch more of (a container might fetch
	 *   multiple connections, but can only paginate one of them). This function is
	 *   given the fragment props only (not full props), and should return the
	 *   connection data. See the above example that returns the friends data via
	 *   `props.user.friends`.
	 * - `getFragmentVariables(previousVars, totalCount)`: Given the previous variables
	 *   and the new total number of items, get the variables to use when reading
	 *   your fragments. Typically this means setting whatever your local "count"
	 *   variable is to the value of `totalCount`. See the example.
	 * - `getVariables(props, {count, cursor})`: Get the variables to use when
	 *   fetching the pagination `query`. You may determine the root object id from
	 *   props (see the example that uses `props.user.id`) and may also set whatever
	 *   variables you use for the after/first/before/last calls based on the count
	 *   and cursor.
	 * - `query`: A query to use when fetching more connection data. This should
	 *   typically reference one of the container's fragment (as in the example)
	 *   to ensure that all the necessary fields for sub-components are fetched.
	 */

	function createGetConnectionFromProps(metadata) {
	  var path = metadata.path;
	  !path ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : require('fbjs/lib/invariant')(false) : void 0;
	  return function (props) {
	    var data = props[metadata.fragmentName];
	    for (var i = 0; i < path.length; i++) {
	      if (!data || typeof data !== 'object') {
	        return null;
	      }
	      data = data[path[i]];
	    }
	    return data;
	  };
	}

	function createGetFragmentVariables(metadata) {
	  var countVariable = metadata.count;
	  !countVariable ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : require('fbjs/lib/invariant')(false) : void 0;
	  return function (prevVars, totalCount) {
	    return (0, _extends4['default'])({}, prevVars, (0, _defineProperty3['default'])({}, countVariable, totalCount));
	  };
	}

	function findConnectionMetadata(fragments) {
	  var foundConnectionMetadata = null;
	  var isRelayModern = false;
	  for (var _fragmentName in fragments) {
	    var fragment = fragments[_fragmentName];
	    var connectionMetadata = fragment.metadata && fragment.metadata.connection;
	    // HACK: metadata is always set to `undefined` in classic. In modern, even
	    // if empty, it is set to null (never undefined). We use that knowlege to
	    // check if we're dealing with classic or modern
	    if (fragment.metadata !== undefined) {
	      isRelayModern = true;
	    }
	    if (connectionMetadata) {
	      !(connectionMetadata.length === 1) ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', _fragmentName, connectionMetadata.length) : require('fbjs/lib/invariant')(false) : void 0;
	      !!foundConnectionMetadata ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : require('fbjs/lib/invariant')(false) : void 0;
	      foundConnectionMetadata = (0, _extends4['default'])({}, connectionMetadata[0], {
	        fragmentName: _fragmentName
	      });
	    }
	  }
	  !(!isRelayModern || foundConnectionMetadata !== null) ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : require('fbjs/lib/invariant')(false) : void 0;
	  return foundConnectionMetadata || {};
	}

	function toObserver(observerOrCallback) {
	  return typeof observerOrCallback === 'function' ? {
	    error: observerOrCallback,
	    complete: observerOrCallback,
	    unsubscribe: function unsubscribe(subscription) {
	      typeof observerOrCallback === 'function' && observerOrCallback();
	    }
	  } : observerOrCallback || {};
	}

	function createContainerWithFragments(Component, fragments, connectionConfig) {
	  var componentName = __webpack_require__(6).getComponentName(Component);
	  var containerName = __webpack_require__(6).getContainerName(Component);

	  var metadata = findConnectionMetadata(fragments);

	  var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);

	  var direction = connectionConfig.direction || metadata.direction;
	  !direction ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : require('fbjs/lib/invariant')(false) : void 0;

	  var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);

	  var Container = function (_React$Component) {
	    (0, _inherits3['default'])(Container, _React$Component);

	    function Container(props, context) {
	      (0, _classCallCheck3['default'])(this, Container);

	      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));

	      _this._handleFragmentDataUpdate = function () {
	        var profiler = __webpack_require__(2).RelayProfiler.profile('ReactRelayPaginationContainer.handleFragmentDataUpdate');
	        _this.setState({ data: _this._resolver.resolve() }, profiler.stop);
	      };

	      _this._hasMore = function () {
	        var connectionData = _this._getConnectionData();
	        return !!(connectionData && connectionData.hasMore && connectionData.cursor);
	      };

	      _this._isLoading = function () {
	        return !!_this._refetchSubscription;
	      };

	      _this._refetchConnection = function (totalCount, observerOrCallback, refetchVariables) {
	        if (!_this._canFetchPage('refetchConnection')) {
	          return {
	            dispose: function dispose() {}
	          };
	        }
	        _this._refetchVariables = refetchVariables;
	        var paginatingVariables = {
	          count: totalCount,
	          cursor: null,
	          totalCount: totalCount
	        };
	        var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), { force: true });

	        return { dispose: fetch.unsubscribe };
	      };

	      _this._loadMore = function (pageSize, observerOrCallback, options) {
	        if (!_this._canFetchPage('loadMore')) {
	          return {
	            dispose: function dispose() {}
	          };
	        }

	        var observer = toObserver(observerOrCallback);
	        var connectionData = _this._getConnectionData();
	        if (!connectionData) {
	          __webpack_require__(2).Observable.create(function (sink) {
	            return sink.complete();
	          }).subscribe(observer);
	          return null;
	        }
	        var totalCount = connectionData.edgeCount + pageSize;
	        if (options && options.force) {
	          return _this._refetchConnection(totalCount, observerOrCallback);
	        }

	        var _ConnectionInterface$ = __webpack_require__(2).ConnectionInterface.get(),
	            END_CURSOR = _ConnectionInterface$.END_CURSOR,
	            START_CURSOR = _ConnectionInterface$.START_CURSOR;

	        var cursor = connectionData.cursor;
	         true ? __webpack_require__(8)(cursor, 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;
	        var paginatingVariables = {
	          count: pageSize,
	          cursor: cursor,
	          totalCount: totalCount
	        };
	        _this._hasPaginated = true;
	        var fetch = _this._fetchPage(paginatingVariables, observer, options);
	        return { dispose: fetch.unsubscribe };
	      };

	      var relay = __webpack_require__(5).assertRelayContext(context.relay);
	      var createFragmentSpecResolver = relay.environment.unstable_internal.createFragmentSpecResolver;

	      _this._isARequestInFlight = false;
	      _this._hasPaginated = false;
	      _this._refetchSubscription = null;
	      _this._refetchVariables = null;
	      _this._resolver = createFragmentSpecResolver(relay, containerName, fragments, props, _this._handleFragmentDataUpdate);
	      _this._relayContext = {
	        environment: relay.environment,
	        variables: relay.variables
	      };
	      _this.state = {
	        data: _this._resolver.resolve(),
	        relayEnvironment: relay.environment,
	        relayProp: _this._buildRelayProp(relay),
	        relayVariables: relay.variables
	      };
	      _this._isUnmounted = false;
	      return _this;
	    }

	    /**
	     * When new props are received, read data for the new props and subscribe
	     * for updates. Props may be the same in which case previous data and
	     * subscriptions can be reused.
	     */


	    Container.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
	      var context = __webpack_require__(47)(nextContext);
	      var relay = __webpack_require__(5).assertRelayContext(context.relay);
	      var _relay$environment$un = relay.environment.unstable_internal,
	          createFragmentSpecResolver = _relay$environment$un.createFragmentSpecResolver,
	          getDataIDsFromObject = _relay$environment$un.getDataIDsFromObject;

	      var prevIDs = getDataIDsFromObject(fragments, this.props);
	      var nextIDs = getDataIDsFromObject(fragments, nextProps);

	      // If the environment has changed or props point to new records then
	      // previously fetched data and any pending fetches no longer apply:
	      // - Existing references are on the old environment.
	      // - Existing references are based on old variables.
	      // - Pending fetches are for the previous records.
	      if (this.state.relayEnvironment !== relay.environment || this.state.relayVariables !== relay.variables || !__webpack_require__(12)(prevIDs, nextIDs)) {
	        this._cleanup();
	        // Child containers rely on context.relay being mutated (for gDSFP).
	        this._relayContext.environment = relay.environment;
	        this._relayContext.variables = relay.variables;
	        this._resolver = createFragmentSpecResolver(relay, containerName, fragments, nextProps, this._handleFragmentDataUpdate);
	        this.setState({
	          relayEnvironment: relay.environment,
	          relayProp: this._buildRelayProp(relay),
	          relayVariables: relay.variables
	        });
	      } else if (!this._hasPaginated) {
	        this._resolver.setProps(nextProps);
	      }
	      var data = this._resolver.resolve();
	      if (data !== this.state.data) {
	        this.setState({ data: data });
	      }
	    };

	    Container.prototype.componentWillUnmount = function componentWillUnmount() {
	      this._isUnmounted = true;
	      this._cleanup();
	    };

	    Container.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	      // Short-circuit if any Relay-related data has changed
	      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {
	        return true;
	      }
	      // Otherwise, for convenience short-circuit if all non-Relay props
	      // are scalar and equal
	      var keys = Object.keys(nextProps);
	      for (var ii = 0; ii < keys.length; ii++) {
	        var _key = keys[ii];
	        if (_key === 'relay') {
	          if (nextState.relayEnvironment !== this.state.relayEnvironment || nextState.relayVariables !== this.state.relayVariables) {
	            return true;
	          }
	        } else {
	          if (!fragments.hasOwnProperty(_key) && !__webpack_require__(2).isScalarAndEqual(nextProps[_key], this.props[_key])) {
	            return true;
	          }
	        }
	      }
	      return false;
	    };

	    Container.prototype._buildRelayProp = function _buildRelayProp(relay) {
	      return {
	        hasMore: this._hasMore,
	        isLoading: this._isLoading,
	        loadMore: this._loadMore,
	        refetchConnection: this._refetchConnection,
	        environment: relay.environment
	      };
	    };

	    /**
	     * Render new data for the existing props/context.
	     */


	    Container.prototype._getConnectionData = function _getConnectionData() {
	      // Extract connection data and verify there are more edges to fetch
	      var _props = this.props,
	          _ = _props.componentRef,
	          restProps = (0, _objectWithoutProperties3['default'])(_props, ['componentRef']);

	      var props = (0, _extends4['default'])({}, restProps, this.state.data);
	      var connectionData = getConnectionFromProps(props);
	      if (connectionData == null) {
	        return null;
	      }

	      var _ConnectionInterface$2 = __webpack_require__(2).ConnectionInterface.get(),
	          EDGES = _ConnectionInterface$2.EDGES,
	          PAGE_INFO = _ConnectionInterface$2.PAGE_INFO,
	          HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE,
	          HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE,
	          END_CURSOR = _ConnectionInterface$2.END_CURSOR,
	          START_CURSOR = _ConnectionInterface$2.START_CURSOR;

	      !(typeof connectionData === 'object') ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : require('fbjs/lib/invariant')(false) : void 0;
	      var edges = connectionData[EDGES];
	      var pageInfo = connectionData[PAGE_INFO];
	      if (edges == null || pageInfo == null) {
	        return null;
	      }
	      !Array.isArray(edges) ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : require('fbjs/lib/invariant')(false) : void 0;
	      !(typeof pageInfo === 'object') ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : require('fbjs/lib/invariant')(false) : void 0;
	      var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];
	      var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];
	      if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {
	         true ? __webpack_require__(8)(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : void 0;
	        return null;
	      }
	      return {
	        cursor: cursor,
	        edgeCount: edges.length,
	        hasMore: hasMore
	      };
	    };

	    Container.prototype._getQueryFetcher = function _getQueryFetcher() {
	      if (!this._queryFetcher) {
	        this._queryFetcher = new (__webpack_require__(10))();
	      }
	      return this._queryFetcher;
	    };

	    Container.prototype._canFetchPage = function _canFetchPage(method) {
	      if (this._isUnmounted) {
	         true ? __webpack_require__(8)(false, 'ReactRelayPaginationContainer: Unexpected call of `%s` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to fetch data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `%s` call.', method, containerName, method) : void 0;
	        return false;
	      }
	      return true;
	    };

	    Container.prototype._fetchPage = function _fetchPage(paginatingVariables, observer, options) {
	      var _this2 = this;

	      var _assertRelayContext = __webpack_require__(5).assertRelayContext(this.context.relay),
	          environment = _assertRelayContext.environment;

	      var _environment$unstable = environment.unstable_internal,
	          createOperationSelector = _environment$unstable.createOperationSelector,
	          getRequest = _environment$unstable.getRequest,
	          getVariablesFromObject = _environment$unstable.getVariablesFromObject;
	      var _props2 = this.props,
	          _ = _props2.componentRef,
	          restProps = (0, _objectWithoutProperties3['default'])(_props2, ['componentRef']);

	      var props = (0, _extends4['default'])({}, restProps, this.state.data);
	      var rootVariables = this._relayContext.variables;
	      var fragmentVariables = getVariablesFromObject(rootVariables, fragments, restProps);
	      fragmentVariables = (0, _extends4['default'])({}, rootVariables, fragmentVariables, this._refetchVariables);
	      var fetchVariables = connectionConfig.getVariables(props, {
	        count: paginatingVariables.count,
	        cursor: paginatingVariables.cursor
	      }, fragmentVariables);
	      !(typeof fetchVariables === 'object' && fetchVariables !== null) ?  true ? __webpack_require__(1)(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : require('fbjs/lib/invariant')(false) : void 0;
	      fetchVariables = (0, _extends4['default'])({}, fetchVariables, this._refetchVariables);

	      var cacheConfig = options ? { force: !!options.force } : undefined;
	      if (cacheConfig && options && options.rerunParamExperimental) {
	        cacheConfig.rerunParamExperimental = options.rerunParamExperimental;
	      }
	      var request = getRequest(connectionConfig.query);
	      var operation = createOperationSelector(request, fetchVariables);

	      var refetchSubscription = null;

	      if (this._refetchSubscription) {
	        this._refetchSubscription.unsubscribe();
	      }

	      var onNext = function onNext(payload, complete) {
	        // Child containers rely on context.relay being mutated (for gDSFP).
	        _this2._relayContext.environment = _this2.context.relay.environment;
	        _this2._relayContext.variables = (0, _extends4['default'])({}, _this2.context.relay.variables, fragmentVariables);
	        var prevData = _this2._resolver.resolve();
	        _this2._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount));
	        var nextData = _this2._resolver.resolve();

	        // Workaround slightly different handling for connection in different
	        // core implementations:
	        // - Classic core requires the count to be explicitly incremented
	        // - Modern core automatically appends new items, updating the count
	        //   isn't required to see new data.
	        //
	        // `setState` is only required if changing the variables would change the
	        // resolved data.
	        // TODO #14894725: remove PaginationContainer equal check
	        if (!__webpack_require__(12)(prevData, nextData)) {
	          _this2.setState({ data: nextData }, complete);
	        } else {
	          complete();
	        }
	      };

	      var cleanup = function cleanup() {
	        if (_this2._refetchSubscription === refetchSubscription) {
	          _this2._refetchSubscription = null;
	          _this2._isARequestInFlight = false;
	        }
	      };

	      this._isARequestInFlight = true;
	      refetchSubscription = this._getQueryFetcher().execute({
	        environment: environment,
	        operation: operation,
	        cacheConfig: cacheConfig,
	        preservePreviousReferences: true
	      }).mergeMap(function (payload) {
	        return __webpack_require__(2).Observable.create(function (sink) {
	          onNext(payload, function () {
	            sink.next(); // pass void to public observer's `next`
	            sink.complete();
	          });
	        });
	      })
	      // use do instead of finally so that observer's `complete` fires after cleanup
	      ['do']({
	        error: cleanup,
	        complete: cleanup,
	        unsubscribe: cleanup
	      }).subscribe(observer || {});

	      this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;

	      return refetchSubscription;
	    };

	    Container.prototype._cleanup = function _cleanup() {
	      this._resolver.dispose();
	      this._hasPaginated = false;
	      this._refetchVariables = null;
	      if (this._refetchSubscription) {
	        this._refetchSubscription.unsubscribe();
	        this._refetchSubscription = null;
	        this._isARequestInFlight = false;
	      }
	      if (this._queryFetcher) {
	        this._queryFetcher.dispose();
	      }
	    };

	    Container.prototype.getChildContext = function getChildContext() {
	      return { relay: this._relayContext };
	    };

	    Container.prototype.render = function render() {
	      var _props3 = this.props,
	          componentRef = _props3.componentRef,
	          props = (0, _objectWithoutProperties3['default'])(_props3, ['componentRef']);

	      return __webpack_require__(3).createElement(Component, (0, _extends4['default'])({}, props, this.state.data, {
	        ref: componentRef,
	        relay: this.state.relayProp
	      }));
	    };

	    return Container;
	  }(__webpack_require__(3).Component);

	  Container.displayName = containerName;
	  Container.contextTypes = containerContextTypes;

	  __webpack_require__(19).profileContainer(Container, 'ReactRelayPaginationContainer');

	  return Container;
	}

	/**
	 * Wrap the basic `createContainer()` function with logic to adapt to the
	 * `context.relay.environment` in which it is rendered. Specifically, the
	 * extraction of the environment-specific version of fragments in the
	 * `fragmentSpec` is memoized once per environment, rather than once per
	 * instance of the container constructed/rendered.
	 */
	function createContainer(Component, fragmentSpec, connectionConfig) {
	  return __webpack_require__(20)(Component, fragmentSpec, function (ComponentClass, fragments) {
	    return createContainerWithFragments(ComponentClass, fragments, connectionConfig);
	  },
	  /* provides child context */true);
	}

	module.exports = { createContainer: createContainer, createContainerWithFragments: createContainerWithFragments };

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	var _possibleConstructorReturn3 = _interopRequireDefault(__webpack_require__(17));

	var _inherits3 = _interopRequireDefault(__webpack_require__(16));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * React may double-fire the constructor, and we call 'fetch' in the
	 * constructor. If a request is already in flight from a previous call to the
	 * constructor, just reuse the query fetcher and wait for the response.
	 */
	var requestCache = {};

	var NETWORK_ONLY = 'NETWORK_ONLY';
	var STORE_THEN_NETWORK = 'STORE_THEN_NETWORK';
	var DataFromEnum = {
	  NETWORK_ONLY: NETWORK_ONLY,
	  STORE_THEN_NETWORK: STORE_THEN_NETWORK
	};

	/**
	 * @public
	 *
	 * Orchestrates fetching and rendering data for a single view or view hierarchy:
	 * - Fetches the query/variables using the given network implementation.
	 * - Normalizes the response(s) to that query, publishing them to the given
	 *   store.
	 * - Renders the pending/fail/success states with the provided render function.
	 * - Subscribes for updates to the root data and re-renders with any changes.
	 */
	var ReactRelayQueryRenderer = function (_React$Component) {
	  (0, _inherits3['default'])(ReactRelayQueryRenderer, _React$Component);

	  // TODO T25783053 Update this component to use the new React context API,
	  // Once we have confirmed that it's okay to raise min React version to 16.3.
	  function ReactRelayQueryRenderer(props, context) {
	    (0, _classCallCheck3['default'])(this, ReactRelayQueryRenderer);

	    // Callbacks are attached to the current instance and shared with static
	    // lifecyles by bundling with state. This is okay to do because the
	    // callbacks don't change in reaction to props. However we should not
	    // "leak" them before mounting (since we would be unable to clean up). For
	    // that reason, we define them as null initially and fill them in after
	    // mounting to avoid leaking memory.
	    var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));

	    _this._relayContext = {
	      // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.
	      environment: _this.props.environment,
	      variables: _this.props.variables
	    };
	    var retryCallbacks = {
	      handleDataChange: null,
	      handleRetryAfterError: null
	    };

	    var queryFetcher = void 0;
	    var requestCacheKey = void 0;
	    if (props.query) {
	      var _query = props.query;

	      // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.

	      var genericEnvironment = props.environment;

	      var getRequest = genericEnvironment.unstable_internal.getRequest;

	      var request = getRequest(_query);
	      requestCacheKey = getRequestCacheKey(request, props.variables);
	      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new (__webpack_require__(10))();
	    } else {
	      queryFetcher = new (__webpack_require__(10))();
	    }

	    _this.state = (0, _extends3['default'])({
	      prevPropsEnvironment: props.environment,
	      prevPropsVariables: props.variables,
	      prevQuery: props.query,
	      queryFetcher: queryFetcher,
	      retryCallbacks: retryCallbacks
	    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));
	    return _this;
	  }

	  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
	    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !__webpack_require__(12)(prevState.prevPropsVariables, nextProps.variables)) {
	      var _query2 = nextProps.query;

	      var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();
	      prevState.queryFetcher.disposeRequest();

	      var _queryFetcher = void 0;
	      if (_query2) {
	        // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.
	        var genericEnvironment = nextProps.environment;
	        var getRequest = genericEnvironment.unstable_internal.getRequest;

	        var request = getRequest(_query2);
	        var _requestCacheKey = getRequestCacheKey(request, nextProps.variables);
	        _queryFetcher = requestCache[_requestCacheKey] ? requestCache[_requestCacheKey].queryFetcher : new (__webpack_require__(10))(prevSelectionReferences);
	      } else {
	        _queryFetcher = new (__webpack_require__(10))(prevSelectionReferences);
	      }
	      return (0, _extends3['default'])({
	        prevQuery: nextProps.query,
	        prevPropsEnvironment: nextProps.environment,
	        prevPropsVariables: nextProps.variables
	      }, fetchQueryAndComputeStateFromProps(nextProps, _queryFetcher, prevState.retryCallbacks
	      // passing no requestCacheKey will cause it to be recalculated internally
	      // and we want the updated requestCacheKey, since variables may have changed
	      ));
	    }

	    return null;
	  };

	  ReactRelayQueryRenderer.prototype.componentDidMount = function componentDidMount() {
	    var _this2 = this;

	    var _state = this.state,
	        retryCallbacks = _state.retryCallbacks,
	        queryFetcher = _state.queryFetcher,
	        requestCacheKey = _state.requestCacheKey;

	    if (requestCacheKey) {
	      delete requestCache[requestCacheKey];
	    }

	    retryCallbacks.handleDataChange = function (params) {
	      var error = params.error == null ? null : params.error;
	      var snapshot = params.snapshot == null ? null : params.snapshot;

	      _this2.setState(function (prevState) {
	        var prevRequestCacheKey = prevState.requestCacheKey;

	        if (prevRequestCacheKey) {
	          delete requestCache[prevRequestCacheKey];
	        }

	        // Don't update state if nothing has changed.
	        if (snapshot === prevState.snapshot && error === prevState.error) {
	          return null;
	        }
	        return {
	          renderProps: getRenderProps(error, snapshot, queryFetcher, retryCallbacks),
	          snapshot: snapshot,
	          requestCacheKey: null
	        };
	      });
	    };

	    retryCallbacks.handleRetryAfterError = function (error) {
	      return _this2.setState(function (prevState) {
	        var prevRequestCacheKey = prevState.requestCacheKey;

	        if (prevRequestCacheKey) {
	          delete requestCache[prevRequestCacheKey];
	        }

	        return {
	          renderProps: getLoadingRenderProps(),
	          requestCacheKey: null
	        };
	      });
	    };

	    // Re-initialize the ReactRelayQueryFetcher with callbacks.
	    // If data has changed since constructions, this will re-render.
	    if (this.props.query) {
	      queryFetcher.setOnDataChange(retryCallbacks.handleDataChange);
	    }
	  };

	  ReactRelayQueryRenderer.prototype.componentDidUpdate = function componentDidUpdate() {
	    // We don't need to cache the request after the component commits
	    var requestCacheKey = this.state.requestCacheKey;

	    if (requestCacheKey) {
	      delete requestCache[requestCacheKey];
	      // HACK
	      delete this.state.requestCacheKey;
	    }
	  };

	  ReactRelayQueryRenderer.prototype.componentWillUnmount = function componentWillUnmount() {
	    this.state.queryFetcher.dispose();
	  };

	  ReactRelayQueryRenderer.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
	    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;
	  };

	  ReactRelayQueryRenderer.prototype.getChildContext = function getChildContext() {
	    return {
	      relay: this._relayContext
	    };
	  };

	  ReactRelayQueryRenderer.prototype.render = function render() {
	    var _state2 = this.state,
	        relayContextEnvironment = _state2.relayContextEnvironment,
	        relayContextVariables = _state2.relayContextVariables,
	        renderProps = _state2.renderProps;

	    // HACK Mutate the context.relay object before updating children,
	    // To account for any changes made by static gDSFP.
	    // Updating this value in gDSFP would be less safe, since props changes
	    // could be interrupted and we might re-render based on a setState call.
	    // Child containers rely on context.relay being mutated (also for gDSFP).
	    // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.

	    this._relayContext.environment = relayContextEnvironment;
	    this._relayContext.variables = relayContextVariables;

	    // Note that the root fragment results in `renderProps.props` is already
	    // frozen by the store; this call is to freeze the renderProps object and
	    // error property if set.
	    if (true) {
	      __webpack_require__(2).deepFreeze(renderProps);
	    }
	    return this.props.render(renderProps);
	  };

	  return ReactRelayQueryRenderer;
	}(__webpack_require__(3).Component);

	ReactRelayQueryRenderer.childContextTypes = {
	  relay: __webpack_require__(11).Relay
	};


	function getLoadingRenderProps() {
	  return {
	    error: null,
	    props: null, // `props: null` indicates that the data is being fetched (i.e. loading)
	    retry: null
	  };
	}

	function getEmptyRenderProps() {
	  return {
	    error: null,
	    props: {}, // `props: {}` indicates no data available
	    retry: null
	  };
	}

	function getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {
	  return {
	    error: error ? error : null,
	    props: snapshot ? snapshot.data : null,
	    retry: function retry() {
	      var syncSnapshot = queryFetcher.retry();
	      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {
	        retryCallbacks.handleDataChange({ snapshot: syncSnapshot });
	      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {
	        // If retrying after an error and no synchronous result available,
	        // reset the render props
	        retryCallbacks.handleRetryAfterError(error);
	      }
	    }
	  };
	}

	function getRequestCacheKey(request, variables) {
	  if (request.kind === 'BatchRequest') {
	    return JSON.stringify({
	      id: request.requests.map(function (req) {
	        return String(req.id || req.text);
	      }),
	      variables: variables
	    });
	  } else {
	    var requestID = request.id || request.text;
	    return JSON.stringify({
	      id: String(requestID),
	      variables: variables
	    });
	  }
	}

	function fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {
	  var environment = props.environment,
	      query = props.query,
	      variables = props.variables;
	  // $FlowFixMe TODO t16225453 QueryRenderer works with old+new environment.

	  var genericEnvironment = environment;
	  if (query) {
	    var _genericEnvironment$u = genericEnvironment.unstable_internal,
	        createOperationSelector = _genericEnvironment$u.createOperationSelector,
	        getRequest = _genericEnvironment$u.getRequest;

	    var request = getRequest(query);
	    var operation = createOperationSelector(request, variables);
	    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {
	      // This same request is already in flight.

	      var _snapshot = requestCache[requestCacheKey].snapshot;

	      if (_snapshot) {
	        // Use the cached response
	        return {
	          error: null,
	          relayContextEnvironment: environment,
	          relayContextVariables: variables,
	          renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),
	          snapshot: _snapshot,
	          requestCacheKey: requestCacheKey
	        };
	      } else {
	        // Render loading state
	        return {
	          error: null,
	          relayContextEnvironment: environment,
	          relayContextVariables: variables,
	          renderProps: getLoadingRenderProps(),
	          snapshot: null,
	          requestCacheKey: requestCacheKey
	        };
	      }
	    }

	    try {
	      var storeSnapshot = props.dataFrom === STORE_THEN_NETWORK ? queryFetcher.lookupInStore(genericEnvironment, operation) : null;
	      var querySnapshot = queryFetcher.fetch({
	        cacheConfig: props.cacheConfig,
	        dataFrom: props.dataFrom,
	        environment: genericEnvironment,
	        onDataChange: retryCallbacks.handleDataChange,
	        operation: operation
	      });

	      // Use network data first, since it may be fresher
	      var _snapshot2 = querySnapshot || storeSnapshot;

	      // cache the request to avoid duplicate requests
	      requestCacheKey = requestCacheKey || getRequestCacheKey(request, props.variables);
	      requestCache[requestCacheKey] = { queryFetcher: queryFetcher, snapshot: _snapshot2 };

	      if (!_snapshot2) {
	        return {
	          error: null,
	          relayContextEnvironment: environment,
	          relayContextVariables: operation.variables,
	          renderProps: getLoadingRenderProps(),
	          snapshot: null,
	          requestCacheKey: requestCacheKey
	        };
	      }

	      return {
	        error: null,
	        relayContextEnvironment: environment,
	        relayContextVariables: operation.variables,
	        renderProps: getRenderProps(null, _snapshot2, queryFetcher, retryCallbacks),
	        snapshot: _snapshot2,
	        requestCacheKey: requestCacheKey
	      };
	    } catch (error) {
	      return {
	        error: error,
	        relayContextEnvironment: environment,
	        relayContextVariables: operation.variables,
	        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),
	        snapshot: null,
	        requestCacheKey: requestCacheKey
	      };
	    }
	  } else {
	    queryFetcher.dispose();

	    return {
	      error: null,
	      relayContextEnvironment: environment,
	      relayContextVariables: variables,
	      renderProps: getEmptyRenderProps(),
	      requestCacheKey: null // if there is an error, don't cache request
	    };
	  }
	}

	module.exports = ReactRelayQueryRenderer;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	var _objectWithoutProperties3 = _interopRequireDefault(__webpack_require__(22));

	var _extends3 = _interopRequireDefault(__webpack_require__(7));

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	var _possibleConstructorReturn3 = _interopRequireDefault(__webpack_require__(17));

	var _inherits3 = _interopRequireDefault(__webpack_require__(16));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var containerContextTypes = {
	  relay: __webpack_require__(11).Relay
	};

	/**
	 * Composes a React component class, returning a new class that intercepts
	 * props, resolving them with the provided fragments and subscribing for
	 * updates.
	 */
	function createContainerWithFragments(Component, fragments, taggedNode) {
	  var containerName = __webpack_require__(6).getContainerName(Component);

	  var Container = function (_React$Component) {
	    (0, _inherits3['default'])(Container, _React$Component);

	    function Container(props, context) {
	      (0, _classCallCheck3['default'])(this, Container);

	      var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));

	      _this._handleFragmentDataUpdate = function () {
	        var profiler = __webpack_require__(2).RelayProfiler.profile('ReactRelayRefetchContainer.handleFragmentDataUpdate');
	        var resolverFromThisUpdate = _this.state.resolver;
	        _this.setState(function (updatedState) {
	          // If this event belongs to the current data source, update.
	          // Otherwise we should ignore it.
	          if (resolverFromThisUpdate === updatedState.resolver) {
	            return {
	              data: updatedState.resolver.resolve()
	            };
	          }

	          return null;
	        }, profiler.stop);
	      };

	      _this._refetch = function (refetchVariables, renderVariables, observerOrCallback, options) {
	        if (_this._isUnmounted) {
	           true ? __webpack_require__(8)(false, 'ReactRelayRefetchContainer: Unexpected call of `refetch` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to refetch the data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `refetch`.', containerName) : void 0;
	          return {
	            dispose: function dispose() {}
	          };
	        }

	        var _assertRelayContext = __webpack_require__(5).assertRelayContext(_this.context.relay),
	            environment = _assertRelayContext.environment,
	            rootVariables = _assertRelayContext.variables;

	        var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;
	        fetchVariables = (0, _extends3['default'])({}, rootVariables, fetchVariables);
	        var fragmentVariables = renderVariables ? (0, _extends3['default'])({}, rootVariables, renderVariables) : fetchVariables;
	        var cacheConfig = options ? { force: !!options.force } : undefined;

	        var observer = typeof observerOrCallback === 'function' ? {
	          // callback is not exectued on complete or unsubscribe
	          // for backward compatibility
	          next: observerOrCallback,
	          error: observerOrCallback
	        } : observerOrCallback || {};

	        var _this$context$relay$e = _this.context.relay.environment.unstable_internal,
	            createOperationSelector = _this$context$relay$e.createOperationSelector,
	            getRequest = _this$context$relay$e.getRequest;

	        var query = getRequest(taggedNode);
	        var operation = createOperationSelector(query, fetchVariables);

	        // TODO: T26288752 find a better way
	        /* eslint-disable lint/react-state-props-mutation */
	        _this.state.localVariables = fetchVariables;
	        /* eslint-enable lint/react-state-props-mutation */

	        // Cancel any previously running refetch.
	        _this._refetchSubscription && _this._refetchSubscription.unsubscribe();

	        // Declare refetchSubscription before assigning it in .start(), since
	        // synchronous completion may call callbacks .subscribe() returns.
	        var refetchSubscription = void 0;
	        _this._getQueryFetcher().execute({
	          environment: environment,
	          operation: operation,
	          cacheConfig: cacheConfig,
	          // TODO (T26430099): Cleanup old references
	          preservePreviousReferences: true
	        }).mergeMap(function (response) {
	          // Child containers rely on context.relay being mutated (for gDSFP).
	          // TODO: T26288752 find a better way
	          /* eslint-disable lint/react-state-props-mutation */
	          _this.state.relayContext.environment = _this.context.relay.environment;
	          _this.state.relayContext.variables = fragmentVariables;
	          /* eslint-enable lint/react-state-props-mutation */
	          _this.state.resolver.setVariables(fragmentVariables);
	          return __webpack_require__(2).Observable.create(function (sink) {
	            return _this.setState({ data: _this.state.resolver.resolve() }, function () {
	              sink.next();
	              sink.complete();
	            });
	          });
	        })['finally'](function () {
	          // Finalizing a refetch should only clear this._refetchSubscription
	          // if the finizing subscription is the most recent call.
	          if (_this._refetchSubscription === refetchSubscription) {
	            _this._refetchSubscription = null;
	          }
	        }).subscribe((0, _extends3['default'])({}, observer, {
	          start: function start(subscription) {
	            _this._refetchSubscription = refetchSubscription = subscription;
	            observer.start && observer.start(subscription);
	          }
	        }));

	        return {
	          dispose: function dispose() {
	            refetchSubscription && refetchSubscription.unsubscribe();
	          }
	        };
	      };

	      var relay = __webpack_require__(5).assertRelayContext(context.relay);
	      var createFragmentSpecResolver = relay.environment.unstable_internal.createFragmentSpecResolver;

	      _this._refetchSubscription = null;
	      // Do not provide a subscription/callback here.
	      // It is possible for this render to be interrupted or aborted,
	      // In which case the subscription would cause a leak.
	      // We will add the subscription in componentDidMount().
	      var resolver = createFragmentSpecResolver(relay, containerName, fragments, props);
	      _this.state = {
	        data: resolver.resolve(),
	        localVariables: null,
	        relay: relay,
	        relayContext: {
	          environment: relay.environment,
	          variables: relay.variables
	        },
	        relayEnvironment: relay.environment,
	        relayProp: {
	          environment: relay.environment,
	          refetch: _this._refetch
	        },
	        prevProps: _this.props,
	        relayVariables: relay.variables,
	        resolver: resolver
	      };
	      _this._isUnmounted = false;
	      return _this;
	    }

	    Container.prototype.componentDidMount = function componentDidMount() {
	      this._subscribeToNewResolver();
	    };

	    Container.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
	      // If the environment has changed or props point to new records then
	      // previously fetched data and any pending fetches no longer apply:
	      // - Existing references are on the old environment.
	      // - Existing references are based on old variables.
	      // - Pending fetches are for the previous records.
	      if (this.state.resolver !== prevState.resolver) {
	        prevState.resolver.dispose();
	        this._queryFetcher && this._queryFetcher.dispose();
	        this._refetchSubscription && this._refetchSubscription.unsubscribe();

	        this._subscribeToNewResolver();
	      }
	    };

	    /**
	     * When new props are received, read data for the new props and add it to
	     * state. Props may be the same in which case previous data can be reused.
	     */


	    Container.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
	      // Any props change could impact the query, so we mirror props in state.
	      // This is an unusual pattern, but necessary for this container usecase.
	      var prevProps = prevState.prevProps;

	      var relay = __webpack_require__(5).assertRelayContext(prevState.relay);

	      var _relay$environment$un = relay.environment.unstable_internal,
	          createFragmentSpecResolver = _relay$environment$un.createFragmentSpecResolver,
	          getDataIDsFromObject = _relay$environment$un.getDataIDsFromObject;

	      var prevIDs = getDataIDsFromObject(fragments, prevProps);
	      var nextIDs = getDataIDsFromObject(fragments, nextProps);

	      var resolver = prevState.resolver;

	      // If the environment has changed or props point to new records then
	      // previously fetched data and any pending fetches no longer apply:
	      // - Existing references are on the old environment.
	      // - Existing references are based on old variables.
	      // - Pending fetches are for the previous records.
	      if (prevState.relayEnvironment !== relay.environment || prevState.relayVariables !== relay.variables || !__webpack_require__(12)(prevIDs, nextIDs)) {
	        // Child containers rely on context.relay being mutated (for gDSFP).
	        var mutatedRelayContext = prevState.relayContext;
	        mutatedRelayContext.environment = relay.environment;
	        mutatedRelayContext.variables = relay.variables;

	        // Do not provide a subscription/callback here.
	        // It is possible for this render to be interrupted or aborted,
	        // In which case the subscription would cause a leak.
	        // We will add the subscription in componentDidUpdate().
	        resolver = createFragmentSpecResolver(relay, containerName, fragments, nextProps);
	        return {
	          data: resolver.resolve(),
	          localVariables: null,
	          prevProps: nextProps,
	          relayContext: mutatedRelayContext,
	          relayEnvironment: relay.environment,
	          relayProp: {
	            environment: relay.environment,
	            // refetch should never really change
	            refetch: prevState.relayProp.refetch
	          },
	          relayVariables: relay.variables,
	          resolver: resolver
	        };
	      } else if (!prevState.localVariables) {
	        resolver.setProps(nextProps);
	      }
	      var data = resolver.resolve();
	      if (data !== prevState.data) {
	        return {
	          data: data,
	          prevProps: nextProps
	        };
	      }
	      return null;
	    };

	    Container.prototype.componentWillUnmount = function componentWillUnmount() {
	      this._isUnmounted = true;
	      this.state.resolver.dispose();
	      this._queryFetcher && this._queryFetcher.dispose();
	      this._refetchSubscription && this._refetchSubscription.unsubscribe();
	    };

	    Container.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
	      // Short-circuit if any Relay-related data has changed
	      if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {
	        return true;
	      }
	      // Otherwise, for convenience short-circuit if all non-Relay props
	      // are scalar and equal
	      var keys = Object.keys(nextProps);
	      for (var ii = 0; ii < keys.length; ii++) {
	        var _key = keys[ii];
	        if (_key === 'relay') {
	          if (nextState.relayEnvironment !== this.state.relayEnvironment || nextState.relayVariables !== this.state.relayVariables) {
	            return true;
	          }
	        } else {
	          if (!fragments.hasOwnProperty(_key) && !__webpack_require__(2).isScalarAndEqual(nextProps[_key], this.props[_key])) {
	            return true;
	          }
	        }
	      }
	      return false;
	    };

	    Container.prototype._subscribeToNewResolver = function _subscribeToNewResolver() {
	      var _state = this.state,
	          data = _state.data,
	          resolver = _state.resolver;

	      // Event listeners are only safe to add during the commit phase,
	      // So they won't leak if render is interrupted or errors.

	      resolver.setCallback(this._handleFragmentDataUpdate);

	      // External values could change between render and commit.
	      // Check for this case, even though it requires an extra store read.
	      var maybeNewData = resolver.resolve();
	      if (data !== maybeNewData) {
	        this.setState({ data: maybeNewData });
	      }
	    };

	    /**
	     * Render new data for the existing props/context.
	     */


	    Container.prototype._getFragmentVariables = function _getFragmentVariables() {
	      var getVariablesFromObject = this.context.relay.environment.unstable_internal.getVariablesFromObject;

	      return getVariablesFromObject(this.context.relay.variables, fragments, this.props);
	    };

	    Container.prototype._getQueryFetcher = function _getQueryFetcher() {
	      if (!this._queryFetcher) {
	        this._queryFetcher = new (__webpack_require__(10))();
	      }
	      return this._queryFetcher;
	    };

	    Container.prototype.getChildContext = function getChildContext() {
	      return { relay: this.state.relayContext };
	    };

	    Container.prototype.render = function render() {
	      var _props = this.props,
	          componentRef = _props.componentRef,
	          props = (0, _objectWithoutProperties3['default'])(_props, ['componentRef']);

	      return __webpack_require__(3).createElement(Component, (0, _extends3['default'])({}, props, this.state.data, {
	        ref: componentRef,
	        relay: this.state.relayProp
	      }));
	    };

	    return Container;
	  }(__webpack_require__(3).Component);

	  Container.displayName = containerName;
	  Container.contextTypes = containerContextTypes;

	  __webpack_require__(19).profileContainer(Container, 'ReactRelayRefetchContainer');

	  return Container;
	}

	/**
	 * Wrap the basic `createContainer()` function with logic to adapt to the
	 * `context.relay.environment` in which it is rendered. Specifically, the
	 * extraction of the environment-specific version of fragments in the
	 * `fragmentSpec` is memoized once per environment, rather than once per
	 * instance of the container constructed/rendered.
	 */
	function createContainer(Component, fragmentSpec, taggedNode) {
	  return __webpack_require__(20)(Component, fragmentSpec, function (ComponentClass, fragments) {
	    return createContainerWithFragments(ComponentClass, fragments, taggedNode);
	  },
	  /* provides child context */true);
	}

	module.exports = { createContainer: createContainer, createContainerWithFragments: createContainerWithFragments };

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Wrap the basic `createContainer()` function with logic to adapt to the
	 * `context.relay.environment` in which it is rendered. Specifically, the
	 * extraction of the environment-specific version of fragments in the
	 * `fragmentSpec` is memoized once per environment, rather than once per
	 * instance of the container constructed/rendered.
	 */
	function createContainer(Component, fragmentSpec) {
	  return __webpack_require__(14).buildCompatContainer(Component, fragmentSpec, __webpack_require__(32).createContainerWithFragments,
	  /* provides child context */false);
	}

	module.exports = { createContainer: createContainer };

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Wrap the basic `createContainer()` function with logic to adapt to the
	 * `context.relay.environment` in which it is rendered. Specifically, the
	 * extraction of the environment-specific version of fragments in the
	 * `fragmentSpec` is memoized once per environment, rather than once per
	 * instance of the container constructed/rendered.
	 */
	function createContainer(Component, fragmentSpec, connectionConfig) {
	  return __webpack_require__(14).buildCompatContainer(Component, fragmentSpec, function (ComponentClass, fragments) {
	    return __webpack_require__(33).createContainerWithFragments(ComponentClass, fragments, connectionConfig);
	  },
	  /* provides child context */true);
	}

	module.exports = { createContainer: createContainer };

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	/**
	 * Wrap the basic `createContainer()` function with logic to adapt to the
	 * `context.relay.environment` in which it is rendered. Specifically, the
	 * extraction of the environment-specific version of fragments in the
	 * `fragmentSpec` is memoized once per environment, rather than once per
	 * instance of the container constructed/rendered.
	 */
	function createContainer(Component, fragmentSpec, taggedNode) {
	  return __webpack_require__(14).buildCompatContainer(Component, fragmentSpec, function (ComponentClass, fragments) {
	    return __webpack_require__(35).createContainerWithFragments(ComponentClass, fragments, taggedNode);
	  },
	  /* provides child context */true);
	}

	module.exports = { createContainer: createContainer };

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	var _classCallCheck3 = _interopRequireDefault(__webpack_require__(9));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * Represents a query fragment that is conditional upon the active route as a
	 * function that returns either a literal fragment or a fragment reference.
	 *
	 * Example GraphQL:
	 *
	 * ```
	 * Node {
	 *   ${(route) => matchRoute(route, ...)}
	 * }
	 * ```
	 */
	var RelayRouteFragment = function () {
	  function RelayRouteFragment(builder) {
	    (0, _classCallCheck3['default'])(this, RelayRouteFragment);

	    this._builder = builder;
	  }

	  /**
	   * Returns the query fragment that matches the given route, if any.
	   */


	  RelayRouteFragment.prototype.getFragmentForRoute = function getFragmentForRoute(route) {
	    return this._builder(route);
	  };

	  return RelayRouteFragment;
	}();

	module.exports = RelayRouteFragment;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict-local
	 * @format
	 */

	'use strict';

	/**
	 * @internal
	 *
	 * Iterates over the identifying arguments in the supplied root call.
	 * If the identifying value is null or undefined, the supplied callback will be
	 * invoked once.
	 */
	function forEachRootCallArg(query, callback) {
	  !!query.getBatchCall() ?  true ? __webpack_require__(1)(false, 'forEachRootCallArg(): Cannot iterate over batch call variables.') : require('fbjs/lib/invariant')(false) : void 0;
	  function each(identifyingArgValue, fn) {
	    if (Array.isArray(identifyingArgValue)) {
	      identifyingArgValue.forEach(function (value) {
	        return each(value, fn);
	      });
	    } else {
	      fn({
	        identifyingArgValue: identifyingArgValue,
	        identifyingArgKey: identifyingArgValue == null ? null : typeof identifyingArgValue === 'string' ? identifyingArgValue : __webpack_require__(43)(identifyingArgValue)
	      });
	    }
	  }
	  var identifyingArg = query.getIdentifyingArg();
	  var identifyingArgValue = identifyingArg && identifyingArg.value || null;
	  each(identifyingArgValue, callback);
	}

	module.exports = forEachRootCallArg;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	function isRelayContainer(component) {
	  return !!(component && component.getFragmentNames && component.getFragment && component.hasFragment && component.hasVariable);
	}

	module.exports = isRelayContainer;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 *  strict
	 * @format
	 */

	'use strict';

	/**
	 * Determine if the object is a plain object that matches the `Variables` type.
	 */

	function isRelayVariables(variables) {
	  return typeof variables === 'object' && variables !== null && !Array.isArray(variables);
	}

	module.exports = isRelayVariables;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 * @format
	 */

	'use strict';

	function isObject(value) {
	  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
	}

	/**
	 * Simple recursive stringifier that handles basic objects (does not handle
	 * corner cases such as circular references) and produces a JSON-like
	 * serialization suitable for use as a cache key or other similar internal
	 * book-keeping detail.
	 *
	 * Sample input:
	 *
	 *     var object = {
	 *       top2: {
	 *         middle: {
	 *           inner: [1, 'foo', ['bar', 2]],
	 *           other: false,
	 *         },
	 *       },
	 *       top1: [
	 *         {first: true},
	 *         {first: false},
	 *         'random',
	 *       ],
	 *       misc: true,
	 *       extra: null,
	 *     };
	 *
	 * Sample output (some whitespace added for clarity):
	 *
	 *    {
	 *      extra:null,
	 *      misc:true,
	 *      top1:[0:{first:true},1:{first:false},2:"random"],
	 *      top2:{middle:{inner:[0:1,1:"foo",2:[0:"bar",1:2]],other:false}}
	 *    }
	 */
	function stableStringify(input) {
	  var inputIsArray = Array.isArray(input);
	  var inputIsObject = isObject(input);
	  if (inputIsArray || inputIsObject) {
	    var keys = Object.keys(input);
	    if (keys.length) {
	      var result = [];
	      keys.sort();

	      for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = input[key];
	        if (isObject(value) || Array.isArray(value)) {
	          value = stableStringify(value);
	        } else {
	          value = JSON.stringify(value);
	        }
	        result.push(key + ':' + value);
	      }

	      if (inputIsArray) {
	        return '[' + result.join(',') + ']';
	      } else {
	        return '{' + result.join(',') + '}';
	      }
	    }
	  }
	  return JSON.stringify(input);
	}

	module.exports = stableStringify;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_47__;

/***/ })
/******/ ])
});
;