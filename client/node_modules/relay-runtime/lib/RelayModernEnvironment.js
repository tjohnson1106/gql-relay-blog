/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */

'use strict';

var _classCallCheck3 = _interopRequireDefault(require('babel-runtime/helpers/classCallCheck'));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var RelayModernEnvironment = function () {
  function RelayModernEnvironment(config) {
    var _this = this;

    (0, _classCallCheck3['default'])(this, RelayModernEnvironment);
    this._deferrableSelections = new Set();

    this.configName = config.configName;
    var handlerProvider = config.handlerProvider ? config.handlerProvider : require('./RelayDefaultHandlerProvider');
    this._network = config.network;
    this._publishQueue = new (require('./RelayPublishQueue'))(config.store, handlerProvider);
    this._store = config.store;
    this.unstable_internal = require('./RelayCore');

    this.__setNet = function (newNet) {
      return _this._network = newNet;
    };

    // Register this Relay Environment with Relay DevTools if it exists.
    // Note: this must always be the last step in the constructor.
    var _global = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : undefined;
    var devToolsHook = _global && _global.__RELAY_DEVTOOLS_HOOK__;
    if (devToolsHook) {
      devToolsHook.registerEnvironment(this);
    }
  }

  RelayModernEnvironment.prototype.getStore = function getStore() {
    return this._store;
  };

  RelayModernEnvironment.prototype.getNetwork = function getNetwork() {
    return this._network;
  };

  RelayModernEnvironment.prototype.applyUpdate = function applyUpdate(optimisticUpdate) {
    var _this2 = this;

    var dispose = function dispose() {
      _this2._publishQueue.revertUpdate(optimisticUpdate);
      _this2._publishQueue.run();
    };
    this._publishQueue.applyUpdate(optimisticUpdate);
    this._publishQueue.run();
    return { dispose: dispose };
  };

  RelayModernEnvironment.prototype.revertUpdate = function revertUpdate(update) {
    this._publishQueue.revertUpdate(update);
    this._publishQueue.run();
  };

  RelayModernEnvironment.prototype.replaceUpdate = function replaceUpdate(update, newUpdate) {
    this._publishQueue.revertUpdate(update);
    this._publishQueue.applyUpdate(newUpdate);
    this._publishQueue.run();
  };

  RelayModernEnvironment.prototype.applyMutation = function applyMutation(_ref) {
    var operation = _ref.operation,
        optimisticResponse = _ref.optimisticResponse,
        optimisticUpdater = _ref.optimisticUpdater;

    return this.applyUpdate({
      operation: operation,
      selectorStoreUpdater: optimisticUpdater,
      response: optimisticResponse || null
    });
  };

  RelayModernEnvironment.prototype.check = function check(readSelector) {
    return this._store.check(readSelector);
  };

  RelayModernEnvironment.prototype.commitPayload = function commitPayload(operationSelector, payload) {
    // Do not handle stripped nulls when commiting a payload
    var relayPayload = require('./normalizeRelayPayload')(operationSelector.root, payload);
    this._publishQueue.commitPayload(operationSelector, relayPayload);
    this._publishQueue.run();
  };

  RelayModernEnvironment.prototype.commitUpdate = function commitUpdate(updater) {
    this._publishQueue.commitUpdate(updater);
    this._publishQueue.run();
  };

  RelayModernEnvironment.prototype.lookup = function lookup(readSelector) {
    return this._store.lookup(readSelector);
  };

  RelayModernEnvironment.prototype.subscribe = function subscribe(snapshot, callback) {
    return this._store.subscribe(snapshot, callback);
  };

  RelayModernEnvironment.prototype.retain = function retain(selector) {
    return this._store.retain(selector);
  };

  RelayModernEnvironment.prototype.isSelectorLoading = function isSelectorLoading(selector) {
    var key = require('./deferrableFragmentKey')(selector.dataID, selector.node.name, selector.variables);
    return this._deferrableSelections.has(key);
  };
  /**
   * Returns an Observable of ExecutePayload resulting from executing the
   * provided Query or Subscription operation, each result of which is then
   * normalized and committed to the publish queue.
   *
   * Note: Observables are lazy, so calling this method will do nothing until
   * the result is subscribed to: environment.execute({...}).subscribe({...}).
   */


  RelayModernEnvironment.prototype.execute = function execute(_ref2) {
    var _this3 = this;

    var operation = _ref2.operation,
        cacheConfig = _ref2.cacheConfig,
        updater = _ref2.updater;

    var optimisticResponse = void 0;
    return this._network.execute(operation.node, operation.variables, cacheConfig || {})['do']({
      next: function next(executePayload) {
        var responsePayload = require('./normalizePayload')(executePayload);
        var source = responsePayload.source,
            fieldPayloads = responsePayload.fieldPayloads,
            deferrableSelections = responsePayload.deferrableSelections;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (deferrableSelections || new Set())[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var selectionKey = _step.value;

            _this3._deferrableSelections.add(selectionKey);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (executePayload.isOptimistic) {
          !(optimisticResponse == null) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'environment.execute: only support one optimistic respnose per ' + 'execute.') : require('fbjs/lib/invariant')(false) : void 0;
          optimisticResponse = {
            source: source,
            fieldPayloads: fieldPayloads
          };
          _this3._publishQueue.applyUpdate(optimisticResponse);
          _this3._publishQueue.run();
        } else {
          if (optimisticResponse) {
            _this3._publishQueue.revertUpdate(optimisticResponse);
            optimisticResponse = undefined;
          }
          var writeSelector = require('./RelayModernOperationSelector').createOperationSelector(operation.node, executePayload.variables, executePayload.operation);
          if (executePayload.operation.kind === 'DeferrableOperation') {
            var fragmentKey = require('./deferrableFragmentKey')(executePayload.variables[executePayload.operation.rootFieldVariable], executePayload.operation.fragmentName, require('./RelayConcreteVariables').getOperationVariables(executePayload.operation, executePayload.variables));
            _this3._deferrableSelections['delete'](fragmentKey);
          }
          _this3._publishQueue.commitPayload(writeSelector, responsePayload, updater);
          _this3._publishQueue.run();
        }
      }
    })['finally'](function () {
      if (optimisticResponse) {
        _this3._publishQueue.revertUpdate(optimisticResponse);
        optimisticResponse = undefined;
        _this3._publishQueue.run();
      }
    });
  };

  /**
   * Returns an Observable of StreamPayload. Similar to .execute({...}),
   * except the stream can also return events, which is especially useful when
   * executing a GraphQL subscription. However, events are not commited to
   * the publish queue, they are simply ignored in the .do({...}) stream.
   */


  RelayModernEnvironment.prototype.executeWithEvents = function executeWithEvents(_ref3) {
    var _this4 = this;

    var operation = _ref3.operation,
        cacheConfig = _ref3.cacheConfig,
        updater = _ref3.updater;

    var optimisticResponse = void 0;
    return this._network.executeWithEvents(operation.node, operation.variables, cacheConfig || {})['do']({
      next: function next(executePayload) {
        if (executePayload.kind !== 'data') {
          return;
        }
        var responsePayload = require('./normalizePayload')(executePayload);
        var source = responsePayload.source,
            fieldPayloads = responsePayload.fieldPayloads,
            deferrableSelections = responsePayload.deferrableSelections;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (deferrableSelections || new Set())[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var selectionKey = _step2.value;

            _this4._deferrableSelections.add(selectionKey);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (executePayload.isOptimistic) {
          !(optimisticResponse == null) ? process.env.NODE_ENV !== 'production' ? require('fbjs/lib/invariant')(false, 'environment.execute: only support one optimistic respnose per ' + 'execute.') : require('fbjs/lib/invariant')(false) : void 0;
          optimisticResponse = {
            source: source,
            fieldPayloads: fieldPayloads
          };
          _this4._publishQueue.applyUpdate(optimisticResponse);
          _this4._publishQueue.run();
        } else {
          if (optimisticResponse) {
            _this4._publishQueue.revertUpdate(optimisticResponse);
            optimisticResponse = undefined;
          }
          var writeSelector = require('./RelayModernOperationSelector').createOperationSelector(operation.node, executePayload.variables, executePayload.operation);
          if (executePayload.operation.kind === 'DeferrableOperation') {
            var fragmentKey = require('./deferrableFragmentKey')(executePayload.variables[executePayload.operation.rootFieldVariable], executePayload.operation.fragmentName, require('./RelayConcreteVariables').getOperationVariables(executePayload.operation, executePayload.variables));
            _this4._deferrableSelections['delete'](fragmentKey);
          }
          _this4._publishQueue.commitPayload(writeSelector, responsePayload, updater);
          _this4._publishQueue.run();
        }
      }
    })['finally'](function () {
      if (optimisticResponse) {
        _this4._publishQueue.revertUpdate(optimisticResponse);
        optimisticResponse = undefined;
        _this4._publishQueue.run();
      }
    });
  };

  /**
   * Returns an Observable of ExecutePayload resulting from executing the
   * provided Mutation operation, the result of which is then normalized and
   * committed to the publish queue along with an optional optimistic response
   * or updater.
   *
   * Note: Observables are lazy, so calling this method will do nothing until
   * the result is subscribed to:
   * environment.executeMutation({...}).subscribe({...}).
   */


  RelayModernEnvironment.prototype.executeMutation = function executeMutation(_ref4) {
    var _this5 = this;

    var operation = _ref4.operation,
        optimisticResponse = _ref4.optimisticResponse,
        optimisticUpdater = _ref4.optimisticUpdater,
        updater = _ref4.updater,
        uploadables = _ref4.uploadables;

    var optimisticUpdate = void 0;
    if (optimisticResponse || optimisticUpdater) {
      optimisticUpdate = {
        operation: operation,
        selectorStoreUpdater: optimisticUpdater,
        response: optimisticResponse || null
      };
    }

    return this._network.execute(operation.node, operation.variables, { force: true }, uploadables)['do']({
      start: function start() {
        if (optimisticUpdate) {
          _this5._publishQueue.applyUpdate(optimisticUpdate);
          _this5._publishQueue.run();
        }
      },
      next: function next(payload) {
        if (optimisticUpdate) {
          _this5._publishQueue.revertUpdate(optimisticUpdate);
          optimisticUpdate = undefined;
        }
        _this5._publishQueue.commitPayload(operation, require('./normalizePayload')(payload), updater);
        _this5._publishQueue.run();
      },
      error: function (_error) {
        function error(_x) {
          return _error.apply(this, arguments);
        }

        error.toString = function () {
          return _error.toString();
        };

        return error;
      }(function (error) {
        if (optimisticUpdate) {
          _this5._publishQueue.revertUpdate(optimisticUpdate);
          optimisticUpdate = undefined;
          _this5._publishQueue.run();
        }
      }),
      unsubscribe: function unsubscribe() {
        if (optimisticUpdate) {
          _this5._publishQueue.revertUpdate(optimisticUpdate);
          optimisticUpdate = undefined;
          _this5._publishQueue.run();
        }
      }
    });
  };

  /**
   * @deprecated Use Environment.execute().subscribe()
   */


  RelayModernEnvironment.prototype.sendQuery = function sendQuery(_ref5) {
    var cacheConfig = _ref5.cacheConfig,
        onCompleted = _ref5.onCompleted,
        onError = _ref5.onError,
        onNext = _ref5.onNext,
        operation = _ref5.operation;

    process.env.NODE_ENV !== 'production' ? require('fbjs/lib/warning')(false, 'environment.sendQuery() is deprecated. Update to the latest ' + 'version of react-relay, and use environment.execute().') : void 0;
    return this.execute({ operation: operation, cacheConfig: cacheConfig }).subscribeLegacy({
      onNext: onNext,
      onError: onError,
      onCompleted: onCompleted
    });
  };

  /**
   * @deprecated Use Environment.executeMutation().subscribe()
   */


  RelayModernEnvironment.prototype.sendMutation = function sendMutation(_ref6) {
    var onCompleted = _ref6.onCompleted,
        onError = _ref6.onError,
        operation = _ref6.operation,
        optimisticResponse = _ref6.optimisticResponse,
        optimisticUpdater = _ref6.optimisticUpdater,
        updater = _ref6.updater,
        uploadables = _ref6.uploadables;

    process.env.NODE_ENV !== 'production' ? require('fbjs/lib/warning')(false, 'environment.sendMutation() is deprecated. Update to the latest ' + 'version of react-relay, and use environment.executeMutation().') : void 0;
    return this.executeMutation({
      operation: operation,
      optimisticResponse: optimisticResponse,
      optimisticUpdater: optimisticUpdater,
      updater: updater,
      uploadables: uploadables
    }).subscribeLegacy({
      // NOTE: sendMutation has a non-standard use of onCompleted() by passing
      // it a value. When switching to use executeMutation(), the next()
      // Observer should be used to preserve behavior.
      onNext: function onNext(payload) {
        onCompleted && onCompleted(payload.response.errors);
      },
      onError: onError,
      onCompleted: onCompleted
    });
  };

  return RelayModernEnvironment;
}();

// Add a sigil for detection by `isRelayModernEnvironment()` to avoid a
// realm-specific instanceof check, and to aid in module tree-shaking to
// avoid requiring all of RelayRuntime just to detect its environment.


RelayModernEnvironment.prototype['@@RelayModernEnvironment'] = true;

module.exports = RelayModernEnvironment;